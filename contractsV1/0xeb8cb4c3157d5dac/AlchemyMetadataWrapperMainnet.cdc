// AUTO-GENERATED CONTRACT
import AADigital from "../0x39eeb4ee6f30fc3f/AADigital.cdc"

import ViewResolver from "../../standardsV1/ViewResolver.cdc"

import ARTIFACT from "../0x24de869c5e40b2eb/ARTIFACT.cdc"

import ARTIFACTPack from "../0x24de869c5e40b2eb/ARTIFACTPack.cdc"

import AllDay from "../0xe4cf4bdc1751c65d/AllDay.cdc"

import AmericanAirlines_NFT from "../0x329feb3ab062d289/AmericanAirlines_NFT.cdc"

import Andbox_NFT from "../0x329feb3ab062d289/Andbox_NFT.cdc"

import Art_NFT from "../0x329feb3ab062d289/Art_NFT.cdc"

import Atheletes_Unlimited_NFT from "../0x329feb3ab062d289/Atheletes_Unlimited_NFT.cdc"

import BarterYardPackNFT from "../0xa95b021cf8a30d80/BarterYardPackNFT.cdc"

import Beam from "../0x86b4a0010a71cfc3/Beam.cdc"

import BlockleteGames_NFT from "../0x329feb3ab062d289/BlockleteGames_NFT.cdc"

import BnGNFT from "../0x7859c48816bfea3c/BnGNFT.cdc"

import BreakingT_NFT from "../0x329feb3ab062d289/BreakingT_NFT.cdc"

import CNN_NFT from "../0x329feb3ab062d289/CNN_NFT.cdc"

import CaaPass from "../0x98c9c2e548b84d31/CaaPass.cdc"

import Canes_Vault_NFT from "../0x329feb3ab062d289/Canes_Vault_NFT.cdc"

import ChainmonstersRewards from "../0x93615d25d14fa337/ChainmonstersRewards.cdc"

import Collectible from "../0xf5b0eb433389ac3f/Collectible.cdc"

import Costacos_NFT from "../0x329feb3ab062d289/Costacos_NFT.cdc"

import Crave from "../0x6d008a788fc27265/Crave.cdc"

import CricketMoments from "../0xed398881d9bf40fb/CricketMoments.cdc"

import CryptoZooNFT from "../0x8ea44ab931cac762/CryptoZooNFT.cdc"

import DGD_NFT from "../0x329feb3ab062d289/DGD_NFT.cdc"

import DayNFT from "../0x1600b04bf033fb99/DayNFT.cdc"

import DieselNFT from "../0x497153c597783bc3/DieselNFT.cdc"

import Domains from "../0x233eb012d34b0070/Domains.cdc"

import DooverseItems from "../0x66ad29c7d7465437/DooverseItems.cdc"

import DropzToken from "../0x2ba17360b76f0143/DropzToken.cdc"

import Eternal from "../0xc38aea683c0c4d38/Eternal.cdc"

import Everbloom from "../0xe703f7fee6400754/Everbloom.cdc"

import FLOAT from "../0x2d4c3caffbeab845/FLOAT.cdc"

import FantastecNFT from "../0x2e1ee1e7a96826ce/FantastecNFT.cdc"

import FlowChinaBadge from "../0x99fed1e8da4c3431/FlowChinaBadge.cdc"

import Gaia from "../0x8b148183c28ff88f/Gaia.cdc"

import GeniaceNFT from "../0xabda6627c70c7f52/GeniaceNFT.cdc"

import GoatedGoats from "../0x2068315349bdfce5/GoatedGoats.cdc"

import GoatedGoatsTrait from "../0x2068315349bdfce5/GoatedGoatsTrait.cdc"

import GogoroCollectible from "../0x8c9bbcdcd7514081/GogoroCollectible.cdc"

import GooberXContract from "../0x34f2bf4a80bb0f69/GooberXContract.cdc"

import HaikuNFT from "../0xf61e40c19db2a9e2/HaikuNFT.cdc"

import ItemNFT from "../0xfc91de5e6566cc7c/ItemNFT.cdc"

import KOTD from "../0x23dddd854fcc8c6f/KOTD.cdc"

import Kicks from "../0xf3cc54f4d91c2f6c/Kicks.cdc"

import KlktnNFT from "../0xabd6e80be7e9682c/KlktnNFT.cdc"

import KlktnNFT2 from "../0xabd6e80be7e9682c/KlktnNFT2.cdc"

import MatrixWorldAssetsNFT from "../0xf20df769e658c257/MatrixWorldAssetsNFT.cdc"

import MatrixWorldFlowFestNFT from "../0x2d2750f240198f91/MatrixWorldFlowFestNFT.cdc"

import MetadataViews from "./../../standardsV1/MetadataViews.cdc"

import Metaverse from "../0xd756450f386fb4ac/Metaverse.cdc"

import MiamiNFT from "../0x429a19abea586a3e/MiamiNFT.cdc"

import MintStoreItem from "../0x20187093790b9aef/MintStoreItem.cdc"

import Momentables from "../0x9d21537544d9123d/Momentables.cdc"

import MusicBlock from "../0x5634aefcb76e7d8c/MusicBlock.cdc"

import Mynft from "../0xf6fcbef550d97aa5/Mynft.cdc"

import NFTContract from "../0x1e075b24abe6eca6/NFTContract.cdc"

import Necryptolis from "../0x718efe5e88fe48ea/Necryptolis.cdc"

import NftReality from "../0x5892036f9111fbb8/NftReality.cdc"

import NonFungibleToken from "./../../standardsV1/NonFungibleToken.cdc"

import NowggNFT from "../0x85b8bbf926dcddfa/NowggNFT.cdc"

import NyatheesOVO from "../0x75e0b6de94eb05d0/NyatheesOVO.cdc"

import OneFootballCollectible from "../0x6831760534292098/OneFootballCollectible.cdc"

import Owners from "../0x41cad19decccdf25/Owners.cdc"

import PackNFT from "../0xe4cf4bdc1751c65d/PackNFT.cdc"

import RCRDSHPNFT from "../0x6c3ff40b90b928ab/RCRDSHPNFT.cdc"

import RaceDay_NFT from "../0x329feb3ab062d289/RaceDay_NFT.cdc"

import RacingTime from "../0x8d4fa88ffa2d9117/RacingTime.cdc"

import RareRooms_NFT from "../0x329feb3ab062d289/RareRooms_NFT.cdc"

import Shard from "../0x82b54037a8f180cf/Shard.cdc"

import SomePlaceCollectible from "../0x667a16294a089ef8/SomePlaceCollectible.cdc"

import SportsIconCollectible from "../0x8de96244f54db422/SportsIconCollectible.cdc"

import StarlyCard from "../0x5b82f21c0edf76e3/StarlyCard.cdc"

import SwaychainNFT from "../0xa4e9020ad21eb30b/SwaychainNFT.cdc"

import TFCItems from "../0x81e95660ab5308e1/TFCItems.cdc"

import TheFabricantMysteryBox_FF1 from "../0xa0cbe021821c0965/TheFabricantMysteryBox_FF1.cdc"

import TheFabricantS1ItemNFT from "../0x9e03b1f871b3513/TheFabricantS1ItemNFT.cdc"

import TheFabricantS2ItemNFT from "../0x7752ea736384322f/TheFabricantS2ItemNFT.cdc"

import The_Next_Cartel_NFT from "../0x329feb3ab062d289/The_Next_Cartel_NFT.cdc"

import TopShot from "../0x0b2a3299cc857e29/TopShot.cdc"

import TuneGO from "../0x0d9bc5af3fc0c2e3/TuneGO.cdc"

import VnMiss from "../0x7c11edb826692404/VnMiss.cdc"

import Vouchers from "../0x444f5ea22c6ea12c/Vouchers.cdc"

import YahooCollectible from "../0x758252ab932a3416/YahooCollectible.cdc"

import YahooPartnersCollectible from "../0x758252ab932a3416/YahooPartnersCollectible.cdc"

import ZeedzINO from "../0x62b3063fbe672fc8/ZeedzINO.cdc"

/*
	A wrapper contract around the script provided by the Alchemy GitHub respository.
	Allows for on-chain storage of NFT Metadata, allowing consumers to query upon.
	This contract will be periodically updated based on new onboarding PRs and deployed.
	Any consumers calling the public methods below will retrieve the latest and greatest data.
*/

access(all)
contract AlchemyMetadataWrapperMainnet{ 
	// Structs copied over as-is from getNFT(ID)?s.cdc for backwards-compatability.
	access(all)
	struct NFTCollection{ 
		access(all)
		let owner: Address
		
		access(all)
		let nfts: [NFTData]
		
		init(owner: Address){ 
			self.owner = owner
			self.nfts = []
		}
	}
	
	access(all)
	struct NFTData{ 
		access(all)
		let contract: NFTContractData
		
		access(all)
		let id: UInt64
		
		access(all)
		let uuid: UInt64?
		
		access(all)
		let title: String?
		
		access(all)
		let description: String?
		
		access(all)
		let external_domain_view_url: String?
		
		access(all)
		let token_uri: String?
		
		access(all)
		let media: [NFTMedia?]
		
		access(all)
		let metadata:{ String: String?}
		
		init(
			_contract: NFTContractData,
			id: UInt64,
			uuid: UInt64?,
			title: String?,
			description: String?,
			external_domain_view_url: String?,
			token_uri: String?,
			media: [
				NFTMedia?
			],
			metadata:{ 
				String: String?
			}
		){ 
			self.contract = _contract
			self.id = id
			self.uuid = uuid
			self.title = title
			self.description = description
			self.external_domain_view_url = external_domain_view_url
			self.token_uri = token_uri
			self.media = media
			self.metadata = metadata
		}
	}
	
	access(all)
	struct NFTContractData{ 
		access(all)
		let name: String
		
		access(all)
		let address: Address
		
		access(all)
		let storage_path: String
		
		access(all)
		let public_path: String
		
		access(all)
		let public_collection_name: String
		
		access(all)
		let external_domain: String
		
		init(
			name: String,
			address: Address,
			storage_path: String,
			public_path: String,
			public_collection_name: String,
			external_domain: String
		){ 
			self.name = name
			self.address = address
			self.storage_path = storage_path
			self.public_path = public_path
			self.public_collection_name = public_collection_name
			self.external_domain = external_domain
		}
	}
	
	access(all)
	struct NFTMedia{ 
		access(all)
		let uri: String?
		
		access(all)
		let mimetype: String?
		
		init(uri: String?, mimetype: String?){ 
			self.uri = uri
			self.mimetype = mimetype
		}
	}
	
	// Same method signature as getNFTs.cdc for backwards-compatability.
	access(all)
	fun getNFTs(ownerAddress: Address, ids:{ String: [UInt64]}): [NFTData?]{ 
		let NFTs: [NFTData?] = []
		let owner = getAccount(ownerAddress)
		for key in ids.keys{ 
			for id in ids[key]!{ 
				var d: NFTData? = nil
				
				// note: unfortunately dictonairy containing functions is not
				// working on mainnet for now so we have to fallback to switch
				switch key{ 
					case "CNN":
						d = self.getCnnNFT(owner: owner, id: id)
					case "ChainmonstersRewards":
						d = self.getChainmonstersRewardNFT(owner: owner, id: id)
					case "Gaia":
						d = self.getGaia(owner: owner, id: id)
					case "TopShot":
						d = self.getTopShot(owner: owner, id: id)
					case "MatrixWorldFlowFestNFT":
						d = self.getMatrixWorldFlowFest(owner: owner, id: id)
					case "StarlyCard":
						d = self.getStarlyCard(owner: owner, id: id)
					case "EternalShard":
						d = self.getEternalShard(owner: owner, id: id)
					case "Mynft":
						d = self.getMynft(owner: owner, id: id)
					case "Vouchers":
						d = self.getVoucher(owner: owner, id: id)
					case "MusicBlock":
						d = self.getMusicBlock(owner: owner, id: id)
					case "NyatheesOVO":
						d = self.getNyatheesOVO(owner: owner, id: id)
					case "RaceDay_NFT":
						d = self.getRaceDay(owner: owner, id: id)
					case "Andbox_NFT":
						d = self.getAndbox_NFT(owner: owner, id: id)
					case "FantastecNFT":
						d = self.getFantastecNFT(owner: owner, id: id)
					case "Everbloom":
						d = self.getEverbloom(owner: owner, id: id)
					case "Domains":
						d = self.getFlownsDomain(owner: owner, id: id)
					case "EternalMoment":
						d = self.getEternalMoment(owner: owner, id: id)
					case "ThingFund":
						d = self.getCaaPass(owner: owner, id: id)
					case "TFCItems":
						d = self.getTFCItems(owner: owner, id: id)
					case "Gooberz":
						d = self.getGooberz(owner: owner, id: id)
					case "MintStoreItem":
						d = self.getMintStoreItem(owner: owner, id: id)
					case "BiscuitsNGroovy":
						d = self.getBiscuitsNGroovy(owner: owner, id: id)
					case "GeniaceNFT":
						d = self.getGeniaceNFT(owner: owner, id: id)
					case "Xtingles":
						d = self.getXtinglesNFT(owner: owner, id: id)
					case "Beam":
						d = self.getBeam(owner: owner, id: id)
					case "KOTD":
						d = self.getKOTD(owner: owner, id: id)
					case "KlktnNFT":
						d = self.getKlktnNFT(owner: owner, id: id)
					case "KlktnNFT2":
						d = self.getKlktnNFT2(owner: owner, id: id)
					case "RareRooms_NFT":
						d = self.getRareRooms(owner: owner, id: id)
					case "Crave":
						d = self.getCrave(owner: owner, id: id)
					case "CricketMoments":
						d = self.getCricketMoments(owner: owner, id: id)
					case "SportsIconCollectible":
						d = self.getSportsIconCollectible(owner: owner, id: id)
					case "InceptionAnimals":
						d = self.getInceptionAnimals(owner: owner, id: id)
					case "OneFootballCollectible":
						d = self.getOneFootballCollectible(owner: owner, id: id)
					case "TheFabricantMysteryBox_FF1":
						d = self.getTheFabricantMysteryBox_FF1(owner: owner, id: id)
					case "DieselNFT":
						d = self.getDieselNFT(owner: owner, id: id)
					case "MiamiNFT":
						d = self.getMiamiNFT(owner: owner, id: id)
					case "Bitku":
						d = self.getBitku(owner: owner, id: id)
					case "FlowFans":
						d = self.getFlowFansNFT(owner: owner, id: id)
					case "AllDay":
						d = self.getAllDay(owner: owner, id: id)
					case "PackNFT":
						d = self.getAllDayPackNFT(owner: owner, id: id)
					case "ItemNFT":
						d = self.getItemNFT(owner: owner, id: id)
					case "TheFabricantS1ItemNFT":
						d = self.getTheFabricantS1ItemNFT(owner: owner, id: id)
					case "ZeedzINO":
						d = self.getZeedzINO(owner: owner, id: id)
					case "Kicks":
						d = self.getKicksSneaker(owner: owner, id: id)
					case "BarterYardPack":
						d = self.getBarterYardPack(owner: owner, id: id)
					case "DayNFT":
						d = self.getDayNFT(owner: owner, id: id)
					case "Costacos_NFT":
						d = self.getCostacosNFT(owner: owner, id: id)
					case "Canes_Vault_NFT":
						d = self.getCanesVaultNFT(owner: owner, id: id)
					case "AmericanAirlines_NFT":
						d = self.getAmericanAirlinesNFT(owner: owner, id: id)
					case "The_Next_Cartel_NFT":
						d = self.getTheNextCartelNFT(owner: owner, id: id)
					case "Atheletes_Unlimited_NFT":
						d = self.getAthletesUnlimitedNFT(owner: owner, id: id)
					case "Art_NFT":
						d = self.getArtNFT(owner: owner, id: id)
					case "DGD_NFT":
						d = self.getDGDNFT(owner: owner, id: id)
					case "NowggNFT":
						d = self.getNowggNFT(owner: owner, id: id)
					case "GogoroCollectible":
						d = self.getGogoroCollectibleNFT(owner: owner, id: id)
					case "YahooCollectible":
						d = self.getYahooCollectibleNFT(owner: owner, id: id)
					case "YahooPartnersCollectible":
						d = self.getYahooPartnersCollectibleNFT(owner: owner, id: id)
					case "SomePlaceCollectible":
						d = self.getSomePlaceCollectibleNFT(owner: owner, id: id)
					case "ARTIFACTPack":
						d = self.getARTIFACTPack(owner: owner, id: id)
					case "ARTIFACT":
						d = self.getARTIFACT(owner: owner, id: id)
					case "NftReality":
						d = self.getNftRealityNFT(owner: owner, id: id)
					case "MatrixWorldAssetsNFT":
						d = self.getNftMatrixWorldAssetsNFT(owner: owner, id: id)
					case "RacingTime":
						d = self.getRacingTimeNFT(owner: owner, id: id)
					case "Momentables":
						d = self.getMomentables(owner: owner, id: id)
					case "GoatedGoats":
						d = self.getGoatedGoats(owner: owner, id: id)
					case "GoatedGoatsTrait":
						d = self.getGoatedGoatsTrait(owner: owner, id: id)
					case "DropzToken":
						d = self.getDropzToken(owner: owner, id: id)
					case "Necryptolis":
						d = self.getNecryptolisNFT(owner: owner, id: id)
					case "FLOAT":
						d = self.getFLOAT(owner: owner, id: id)
					case "BreakingT_NFT":
						d = self.getBreakingTNFT(owner: owner, id: id)
					case "Owners":
						d = self.getOwnersNFT(owner: owner, id: id)
					case "Metaverse":
						d = self.getOzoneMetaverseNFT(owner: owner, id: id)
					case "NFTContract":
						d = self.getNFTContract(owner: owner, id: id)
					case "Swaychain":
						d = self.getSwaychainNFT(owner: owner, id: id)
					case "TheFabricantS2ItemNFT":
						d = self.getTheFabricantS2ItemNFT(owner: owner, id: id)
					case "VnMiss":
						d = self.getVnMiss(owner: owner, id: id)
					case "AvatarArt":
						d = self.getAvatarArt(owner: owner, id: id)
					case "Dooverse":
						d = self.getDooverseNFT(owner: owner, id: id)
					default:
						panic("adapter for NFT not found: ".concat(key))
				}
				NFTs.append(d)
			}
		}
		return NFTs
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/CNN_NFT
	access(all)
	fun getCnnNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "CNN_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "CNN_NFT.CollectionStoragePath",
				public_path: "CNN_NFT.CollectionPublicPath",
				public_collection_name: "CNN_NFT.CNN_NFTCollectionPublic",
				external_domain: "https://vault.cnn.com/"
			)
		let col =
			owner.capabilities.get<&{CNN_NFT.CNN_NFTCollectionPublic}>(CNN_NFT.CollectionPublicPath)
				.borrow<&{CNN_NFT.CNN_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCNN_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = CNN_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			CNN_NFT.getSeriesMetadata(seriesId: CNN_NFT.getSetSeriesId(setId: (nft!).setId)!)
		let seriesId = CNN_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = CNN_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			((setMeta!)["external_url"]!).concat("tokens/").concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x93615d25d14fa337/contract/ChainmonstersRewards
	access(all)
	fun getChainmonstersRewardNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "ChainmonstersRewards",
				address: 0x93615d25d14fa337,
				storage_path: "/storage/ChainmonstersRewardCollection",
				public_path: "/public/ChainmonstersRewardCollection",
				public_collection_name: "ChainmonstersRewards.ChainmonstersRewardCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}>(
				/public/ChainmonstersRewardCollection
			).borrow<&{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowReward(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x8b148183c28ff88f/contract/Gaia
	access(all)
	fun getGaia(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Gaia",
				address: 0x8b148183c28ff88f,
				storage_path: "Gaia.CollectionStoragePath",
				public_path: "Gaia.CollectionPublicPath",
				public_collection_name: "Gaia.CollectionPublic",
				external_domain: "ballerz.xyz"
			)
		let col =
			owner.capabilities.get<&{Gaia.CollectionPublic}>(Gaia.CollectionPublicPath).borrow<
				&{Gaia.CollectionPublic}
			>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowGaiaNFT(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = Gaia.getTemplateMetaData(templateID: (nft!).data.templateID)
		(		 
		 // Populate Gaia NFT data attributes into the metadata
		 metadata!).insert(key: "setID", (nft!).data.setID.toString())
		(metadata!).insert(key: "templateID", (nft!).data.templateID.toString())
		(metadata!).insert(key: "mintNumber", (nft!).data.mintNumber.toString())
		let rawMetadata:{ String: String?} ={} 
		for key in (metadata!).keys{ 
			rawMetadata.insert(key: key, (metadata!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (metadata!)["title"],
			description: (metadata!)["description"],
			external_domain_view_url: (metadata!)["uri"],
			token_uri: nil,
			media: [NFTMedia(uri: (metadata!)["img"], mimetype: "image")],
			metadata: rawMetadata
		)
	}
	
	access(all)
	fun stringStartsWith(string: String, prefix: String): Bool{ 
		if string.length < prefix.length{ 
			return false
		}
		let beginning = string.slice(from: 0, upTo: prefix.length)
		let prefixArray = prefix.utf8
		let beginningArray = beginning.utf8
		for index, element in prefixArray{ 
			if beginningArray[index] != prefixArray[index]{ 
				return false
			}
		}
		return true
	}
	
	// https://flow-view-source.com/mainnet/account/0x86b4a0010a71cfc3/contract/Beam
	access(all)
	fun getBeam(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Beam",
				address: 0x86b4a0010a71cfc3,
				storage_path: "Beam.CollectionStoragePath",
				public_path: "Beam.CollectionPublicPath",
				public_collection_name: "Beam.BeamCollectionPublic",
				external_domain: "frightclub.niftory.com"
			)
		let col =
			owner.capabilities.get<&{Beam.BeamCollectionPublic}>(Beam.CollectionPublicPath).borrow<
				&{Beam.BeamCollectionPublic}
			>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCollectible(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata =
			Beam.getCollectibleItemMetaData(collectibleItemID: (nft!).data.collectibleItemID)
		let ipfsScheme = "ipfs://"
		let httpsScheme = "https://"
		var mediaUrl: String? = nil
		if (metadata!)["mediaUrl"] != nil{ 
			let metadataUrl = (metadata!)["mediaUrl"]!
			if self.stringStartsWith(string: metadataUrl, prefix: ipfsScheme) || self.stringStartsWith(string: metadataUrl, prefix: httpsScheme){ 
				mediaUrl = metadataUrl
			} else if metadataUrl.length > 0{ 
				mediaUrl = ipfsScheme.concat(metadataUrl)
			}
		}
		var domainUrl: String? = nil
		if (metadata!)["domainUrl"] != nil{ 
			let metadataDomainUrl = (metadata!)["domainUrl"]!
			if self.stringStartsWith(string: metadataDomainUrl, prefix: httpsScheme){ 
				domainUrl = metadataDomainUrl
			} else if metadataDomainUrl.length > 0{ 
				domainUrl = httpsScheme.concat(metadataDomainUrl)
			}
		}
		let rawMetadata:{ String: String?} ={} 
		for key in (metadata!).keys{ 
			rawMetadata.insert(key: key, (metadata!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (metadata!)["title"],
			description: (metadata!)["description"],
			external_domain_view_url: domainUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: mediaUrl, mimetype: (metadata!)["mediaType"]),
				NFTMedia(
					uri: "ipfs://bafybeichtxzrocxo7ec5qybfxxlyod5bbymblitjwb2aalv2iyhe42pk4e/Frightclub.jpg",
					mimetype: "image/jpeg"
				)
			],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/BlockleteGames_NFT
	access(all)
	fun getBlockleteGames(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "BlockleteGames_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "BlockleteGames_NFT.CollectionStoragePath",
				public_path: "BlockleteGames_NFT.CollectionPublicPath",
				public_collection_name: "BlockleteGames_NFT.BlockleteGames_NFTCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{BlockleteGames_NFT.BlockleteGames_NFTCollectionPublic}>(
				BlockleteGames_NFT.CollectionPublicPath
			).borrow<&{BlockleteGames_NFT.BlockleteGames_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowBlockleteGames_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x6d008a788fc27265/contract/Crave
	access(all)
	fun getCrave(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Crave",
				address: 0x6d008a788fc27265,
				storage_path: "Crave.CollectionStoragePath",
				public_path: "Crave.CollectionPublicPath",
				public_collection_name: "Crave.CraveCollectionPublic",
				external_domain: "crave.niftory.com"
			)
		let col =
			owner.capabilities.get<&{Crave.CraveCollectionPublic}>(Crave.CollectionPublicPath)
				.borrow<&{Crave.CraveCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCollectible(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata =
			Crave.getCollectibleItemMetaData(collectibleItemID: (nft!).data.collectibleItemID)
		let ipfsScheme = "ipfs://"
		let httpsScheme = "https://"
		var mediaUrl: String? = nil
		if (metadata!)["mediaUrl"] != nil{ 
			let metadataUrl = (metadata!)["mediaUrl"]!
			if self.stringStartsWith(string: metadataUrl, prefix: ipfsScheme) || self.stringStartsWith(string: metadataUrl, prefix: httpsScheme){ 
				mediaUrl = metadataUrl
			} else if metadataUrl.length > 0{ 
				mediaUrl = ipfsScheme.concat(metadataUrl)
			}
		}
		var domainUrl: String? = nil
		if (metadata!)["domainUrl"] != nil{ 
			let metadataDomainUrl = (metadata!)["domainUrl"]!
			if self.stringStartsWith(string: metadataDomainUrl, prefix: httpsScheme){ 
				domainUrl = metadataDomainUrl
			} else if metadataDomainUrl.length > 0{ 
				domainUrl = httpsScheme.concat(metadataDomainUrl)
			}
		}
		let rawMetadata:{ String: String?} ={} 
		for key in (metadata!).keys{ 
			rawMetadata.insert(key: key, (metadata!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (metadata!)["title"],
			description: (metadata!)["description"],
			external_domain_view_url: domainUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: mediaUrl, mimetype: (metadata!)["mediaType"]),
				NFTMedia(
					uri: "ipfs://bafybeiedrlfjykj4svmaka7jdxnhr3osigtudyrhitxsf7ska5ljeiwlxa/Crave Critics Banner.jpg",
					mimetype: "image/jpeg"
				)
			],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xed398881d9bf40fb/contract/CricketMoments
	access(all)
	fun getCricketMoments(owner: &Account, id: UInt64): NFTData?{ 
		let col =
			owner.capabilities.get<&{CricketMoments.CricketMomentsCollectionPublic}>(
				CricketMoments.CollectionPublicPath
			).borrow<&{CricketMoments.CricketMomentsCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		if let nft = (col!).borrowCricketMoment(id: id){ 
			let _contract = NFTContractData(name: "CricketMoments", address: 0xed398881d9bf40fb, storage_path: "CricketMoments.CollectionStoragePath", public_path: "CricketMoments.CollectionPublicPath", public_collection_name: "CricketMoments.CricketMomentsCollectionPublic", external_domain: "")
			let metadata = (nft!).getMetadata()
			let rawMetadata:{ String: String?} ={} 
			for key in (metadata!).keys{ 
				rawMetadata.insert(key: key, (metadata!)[key])
			}
			return NFTData(_contract: _contract, id: (nft!).id, uuid: (nft!).uuid, title: nil, description: metadata["description"], external_domain_view_url: nil, token_uri: "https://gateway.pinata.cloud/ipfs/".concat(metadata["ipfs"]!), media: [], metadata: rawMetadata)
		}
		return nil
	}
	
	// https://flow-view-source.com/mainnet/account/0xe703f7fee6400754/contract/Everbloom
	access(all)
	fun getEverbloom(owner: &Account, id: UInt64): NFTData?{ 
		let col =
			owner.capabilities.get<&{Everbloom.PrintCollectionPublic}>(
				Everbloom.CollectionPublicPath
			).borrow<&{Everbloom.PrintCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		if let nft = (col!).borrowPrint(id: id){ 
			let metadata = nft.data
			let _contract = NFTContractData(name: "Everbloom", address: 0xe703f7fee6400754, storage_path: "Everbloom.CollectionStoragePath", public_path: "Everbloom.CollectionPublicPath", public_collection_name: "Everbloom.PrintCollectionPublic", external_domain: "https://web.everbloom.app/")
			return NFTData(_contract: _contract, id: (nft!).id, uuid: (nft!).uuid, title: nil, description: nil, external_domain_view_url: nil, token_uri: "https://everbloom-fcl-service.herokuapp.com/v1/nft/".concat((nft!).id.toString()), media: [], metadata:{} )
		}
		return nil
	}
	
	// https://flow-view-source.com/mainnet/account/0xc38aea683c0c4d38/contract/Eternal
	access(all)
	fun getEternalMoment(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Eternal",
				address: 0xc38aea683c0c4d38,
				storage_path: "/storage/EternalMomentCollection",
				public_path: "/public/EternalMomentCollection",
				public_collection_name: "Eternal.MomentCollectionPublic",
				external_domain: "https://eternal.gg/"
			)
		let col =
			owner.capabilities.get<&{Eternal.MomentCollectionPublic}>(
				/public/EternalMomentCollection
			).borrow<&{Eternal.MomentCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowMoment(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = Eternal.getPlayMetaData(playID: (nft!).data.playID)
		if metadata == nil{ 
			return nil
		}
		let rawMetadata:{ String: String?} ={} 
		for key in (metadata!).keys{ 
			rawMetadata.insert(key: key, (metadata!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (metadata!)["Title"],
			description: ((metadata!)["Game"]!).concat(" - ").concat((metadata!)["Influencer"]!),
			external_domain_view_url: "https://eternal.gg/moments/".concat((nft!).id.toString()),
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://gateway.pinata.cloud/ipfs/".concat((metadata!)["Hash"]!),
					mimetype: "video"
				)
			],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x82b54037a8f180cf/contract/Shard
	access(all)
	fun getEternalShard(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Shard",
				address: 0x82b54037a8f180cf,
				storage_path: "/storage/EternalShardCollection",
				public_path: "/public/EternalShardCollection",
				public_collection_name: "Shard.ShardCollectionPublic",
				external_domain: "https://eternal.gg/"
			)
		let col =
			owner.capabilities.get<&{Shard.ShardCollectionPublic}>(/public/EternalShardCollection)
				.borrow<&{Shard.ShardCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowShardNFT(id: id)
		if nft == nil{ 
			return nil
		}
		let clip = Shard.getClip(clipID: (nft!).clipID)
		let clipMetadata = Shard.getClipMetadata(clipID: (nft!).clipID)
		let momentMetadata = Shard.getMomentMetadata(momentID: (clip!).momentID)
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (clipMetadata!)["title"],
			description: "Deposit your Shard at Eternal.gg to merge them into a Crystal!",
			external_domain_view_url: "https://eternal.gg/shards/".concat((nft!).id.toString()),
			token_uri: nil,
			media: [NFTMedia(uri: (clipMetadata!)["video_url"], mimetype: "video")],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x2e1ee1e7a96826ce/contract/FantastecNFT
	access(all)
	fun getFantastecNFT(owner: &Account, id: UInt64): NFTData?{ 
		let col =
			owner.capabilities.get<&{FantastecNFT.FantastecNFTCollectionPublic}>(
				FantastecNFT.CollectionPublicPath
			).borrow<&{FantastecNFT.FantastecNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		if let nft = (col!).borrowFantastecNFT(id: id){ 
			//if does not resolve to nil this code will be executed
			let _contract = NFTContractData(name: "FantastecNFT", address: 0x2e1ee1e7a96826ce, storage_path: "FantastecNFT.CollectionStoragePath", public_path: "FantastecNFT.CollectionPublicPath", public_collection_name: "FantastecNFT.FantastecNFTCollectionPublic", external_domain: "")
			let rawMetadata:{ String: String?} ={} 
			for key in nft.metadata.keys{ 
				rawMetadata.insert(key: key, nft.metadata[key])
			}
			return NFTData(_contract: _contract, id: nft.id, uuid: nft.uuid, title: nft.metadata["title"], description: nft.metadata["description"], external_domain_view_url: nil, token_uri: nil, media: [NFTMedia(uri: nft.metadata["image"], mimetype: "image/png")], metadata: rawMetadata)
		}
		return nil
	}
	
	// https://flow-view-source.com/mainnet/account/0x444f5ea22c6ea12c/contract/Vouchers
	access(all)
	fun getVoucher(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Vouchers",
				address: 0x444f5ea22c6ea12c,
				storage_path: "Vouchers.CollectionStoragePath",
				public_path: "Vouchers.CollectionPublicPath",
				public_collection_name: "Vouchers.CollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{Vouchers.CollectionPublic}>(Vouchers.CollectionPublicPath)
				.borrow<&{Vouchers.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowVoucher(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = (nft!).getMetadata()
		if metadata == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (metadata!).name,
			description: (metadata!).description,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [NFTMedia(uri: (metadata!).mediaURI, mimetype: (metadata!).mediaType)],
			metadata:{ 
				"mediaHash": (metadata!).mediaURI,
				"mediaType": (metadata!).mediaType,
				"mediaURI": (metadata!).mediaURI,
				"name": (metadata!).name,
				"description": (metadata!).description,
				"typeID": (nft!).typeID.toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x23dddd854fcc8c6f/contract/KOTD
	access(all)
	fun getKOTD(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "KOTD",
				address: 0x23dddd854fcc8c6f,
				storage_path: "KOTD.CollectionStoragePath",
				public_path: "KOTD.CollectionPublicPath",
				public_collection_name: "KOTD.NiftoryCollectibleCollectionPublic",
				external_domain: "kotd.niftory.com"
			)
		let col =
			owner.capabilities.get<&{KOTD.NiftoryCollectibleCollectionPublic}>(
				KOTD.CollectionPublicPath
			).borrow<&{KOTD.NiftoryCollectibleCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCollectible(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata =
			KOTD.getCollectibleItemMetaData(collectibleItemID: (nft!).data.collectibleItemID)
		let ipfsScheme = "ipfs://"
		let httpsScheme = "https://"
		var mediaUrl: String? = nil
		if (metadata!)["mediaUrl"] != nil{ 
			let metadataUrl = (metadata!)["mediaUrl"]!
			if self.stringStartsWith(string: metadataUrl, prefix: ipfsScheme) || self.stringStartsWith(string: metadataUrl, prefix: httpsScheme){ 
				mediaUrl = metadataUrl
			} else if metadataUrl.length > 0{ 
				mediaUrl = ipfsScheme.concat(metadataUrl)
			}
		}
		var domainUrl: String? = nil
		if (metadata!)["domainUrl"] != nil{ 
			let metadataDomainUrl = (metadata!)["domainUrl"]!
			if self.stringStartsWith(string: metadataDomainUrl, prefix: httpsScheme){ 
				domainUrl = metadataDomainUrl
			} else if metadataDomainUrl.length > 0{ 
				domainUrl = httpsScheme.concat(metadataDomainUrl)
			}
		}
		let rawMetadata:{ String: String?} ={} 
		for key in (metadata!).keys{ 
			rawMetadata.insert(key: key, (metadata!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (metadata!)["title"],
			description: (metadata!)["description"],
			external_domain_view_url: domainUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: mediaUrl, mimetype: (metadata!)["mediaType"]),
				NFTMedia(
					uri: "ipfs://bafybeidy62mofvdpzr5gujq57kcpm27pciqx33pahxbfuwgzea646k2nay/s1_poster.jpg",
					mimetype: "image/jpeg"
				)
			],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xabd6e80be7e9682c/contract/KlktnNFT
	access(all)
	fun getKlktnNFT(owner: &Account, id: UInt64): NFTData?{ 
		let col =
			owner.capabilities.get<&{KlktnNFT.KlktnNFTCollectionPublic}>(
				KlktnNFT.CollectionPublicPath
			).borrow<&{KlktnNFT.KlktnNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		if let nft = (col!).borrowKlktnNFT(id: id){ 
			let metadata = (nft!).getNFTMetadata()
			let _contract = NFTContractData(name: "KlktnNFT", address: 0xabd6e80be7e9682c, storage_path: "KlktnNFT.CollectionStoragePath", public_path: "KlktnNFT.CollectionPublicPath", public_collection_name: "KlktnNFT.KlktnNFTCollectionPublic", external_domain: "")
			let rawMetadata:{ String: String?} ={} 
			for key in (metadata!).keys{ 
				rawMetadata.insert(key: key, (metadata!)[key])
			}
			return NFTData(_contract: _contract, id: (nft!).id, uuid: (nft!).uuid, title: metadata["name"], description: metadata["description"], external_domain_view_url: nil, token_uri: nil, media: [NFTMedia(uri: metadata["media"], mimetype: metadata["mimeType"])], metadata: rawMetadata)
		}
		return nil
	}
	
	// https://flow-view-source.com/mainnet/account/0xabd6e80be7e9682c/contract/KlktnNFT2
	access(all)
	fun getKlktnNFT2(owner: &Account, id: UInt64): NFTData?{ 
		let col =
			owner.capabilities.get<&{KlktnNFT2.KlktnNFTCollectionPublic}>(
				KlktnNFT2.CollectionPublicPath
			).borrow<&{KlktnNFT2.KlktnNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		if let nft = (col!).borrowKlktnNFT(id: id){ 
			let template = (nft!).getFullMetadata()
			let _contract = NFTContractData(name: "KlktnNFT2", address: 0xabd6e80be7e9682c, storage_path: "KlktnNFT2.CollectionStoragePath", public_path: "KlktnNFT2.CollectionPublicPath", public_collection_name: "KlktnNFT2.KlktnNFTCollectionPublic", external_domain: "")
			let rawMetadata:{ String: String?} ={} 
			for key in template.metadata.keys{ 
				rawMetadata.insert(key: key, template.metadata[key])
			}
			return NFTData(_contract: _contract, id: (nft!).id, uuid: (nft!).uuid, title: template.metadata["name"] ?? "", description: template.metadata["description"] ?? "", external_domain_view_url: nil, token_uri: template.metadata["uri"] ?? "", media: [NFTMedia(uri: template.metadata["media"] ?? "", mimetype: template.metadata["mimeType"] ?? "")], metadata: rawMetadata)
		}
		return nil
	}
	
	// https://flow-view-source.com/mainnet/account/0x5634aefcb76e7d8c/contract/MusicBlock
	access(all)
	fun getMusicBlock(owner: &Account, id: UInt64): NFTData?{ 
		let col =
			owner.capabilities.get<&{MusicBlock.MusicBlockCollectionPublic}>(
				MusicBlock.CollectionPublicPath
			).borrow<&{MusicBlock.MusicBlockCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let data = (col!).getMusicBlockData(id: id)
		let nft = (col!).borrowNFT(id: id)
		let token_uri = (col!).getUri(id: id)
		let _contract =
			NFTContractData(
				name: "MusicBlock",
				address: 0x5634aefcb76e7d8c,
				storage_path: "MusicBlock.CollectionStoragePath",
				public_path: "MusicBlock.CollectionPublicPath",
				public_collection_name: "MusicBlock.MusicBlockCollectionPublic",
				external_domain: "melos.studio"
			)
		return NFTData(
			_contract: _contract,
			id: id,
			uuid: nft.uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: token_uri,
			media: [],
			metadata:{ 
				"creator": data.creator.toString(),
				"cpower": data.cpower.toString(),
				"cid": data.cid,
				"generation": data.generation.toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xf6fcbef550d97aa5/contract/Mynft
	access(all)
	fun getMynft(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Mynft",
				address: 0xf6fcbef550d97aa5,
				storage_path: "Mynft.CollectionStoragePath",
				public_path: "Mynft.CollectionPublicPath",
				public_collection_name: "Mynft.MynftCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{Mynft.MynftCollectionPublic}>(Mynft.CollectionPublicPath)
				.borrow<&{Mynft.MynftCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowArt(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: ((nft!).metadata!).name,
			description: ((nft!).metadata!).description,
			external_domain_view_url: "",
			token_uri: nil,
			media: [NFTMedia(uri: ((nft!).metadata!).ipfsLink, mimetype: ((nft!).metadata!).type)],
			metadata:{ 
				"artist": ((nft!).metadata!).artist,
				"arLink": ((nft!).metadata!).arLink,
				"ipfsLink": ((nft!).metadata!).ipfsLink,
				"MD5Hash": ((nft!).metadata!).MD5Hash,
				"type": ((nft!).metadata!).type,
				"name": ((nft!).metadata!).name,
				"description": ((nft!).metadata!).description
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x75e0b6de94eb05d0/contract/NyatheesOVO
	access(all)
	fun getNyatheesOVO(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "NyatheesOVO",
				address: 0x75e0b6de94eb05d0,
				storage_path: "NyatheesOVO.CollectionStoragePath",
				public_path: "NyatheesOVO.CollectionPublicPath",
				public_collection_name: "NyatheesOVO.NFTCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{NyatheesOVO.NFTCollectionPublic}>(
				NyatheesOVO.CollectionPublicPath
			).borrow<&{NyatheesOVO.NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowNFTItem(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = (nft!).getMetadata()
		let rawMetadata:{ String: String?} ={} 
		for key in (metadata!).keys{ 
			rawMetadata.insert(key: key, (metadata!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: metadata["url"],
			token_uri: nil,
			media: [],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/RaceDay_NFT
	access(all)
	fun getRaceDay(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "RaceDay_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "RaceDay_NFT.CollectionStoragePath",
				public_path: "RaceDay_NFT.CollectionPublicPath",
				public_collection_name: "RaceDay_NFT.RaceDay_NFTCollectionPublic",
				external_domain: "https://racedaynft.com/"
			)
		let col =
			owner.capabilities.get<&{RaceDay_NFT.RaceDay_NFTCollectionPublic}>(
				RaceDay_NFT.CollectionPublicPath
			).borrow<&{RaceDay_NFT.RaceDay_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowRaceDay_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = RaceDay_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			RaceDay_NFT.getSeriesMetadata(
				seriesId: RaceDay_NFT.getSetSeriesId(setId: (nft!).setId)!
			)
		let seriesId = RaceDay_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = RaceDay_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			((setMeta!)["external_url"]!).concat("/tokens/").concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/Andbox_NFT
	access(all)
	fun getAndbox_NFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Andbox_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "Andbox_NFT.CollectionStoragePath",
				public_path: "Andbox_NFT.CollectionPublicPath",
				public_collection_name: "Andbox_NFT.Andbox_NFTCollectionPublic",
				external_domain: "https://andbox.shops.nftbridge.com/"
			)
		let col =
			owner.capabilities.get<&{Andbox_NFT.Andbox_NFTCollectionPublic}>(
				Andbox_NFT.CollectionPublicPath
			).borrow<&{Andbox_NFT.Andbox_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowAndbox_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = Andbox_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			Andbox_NFT.getSeriesMetadata(seriesId: Andbox_NFT.getSetSeriesId(setId: (nft!).setId)!)
		let seriesId = Andbox_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = Andbox_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			"https://andbox.shops.nftbridge.com/tokens/".concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/RareRooms_NFT
	access(all)
	fun getRareRooms(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "RareRooms_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "RareRooms_NFT.CollectionStoragePath",
				public_path: "RareRooms_NFT.CollectionPublicPath",
				public_collection_name: "RareRooms_NFT.RareRooms_NFTCollectionPublic",
				external_domain: "https://rarerooms.io/"
			)
		let col =
			owner.capabilities.get<&{RareRooms_NFT.RareRooms_NFTCollectionPublic}>(
				RareRooms_NFT.CollectionPublicPath
			).borrow<&{RareRooms_NFT.RareRooms_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowRareRooms_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = RareRooms_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			RareRooms_NFT.getSeriesMetadata(
				seriesId: RareRooms_NFT.getSetSeriesId(setId: (nft!).setId)!
			)
		let seriesId = RareRooms_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = RareRooms_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl = "https://rarerooms.io/tokens/".concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x6c3ff40b90b928ab/contract/RCRDSHPNFT
	access(all)
	fun getRCRDSHPNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "RCRDSHPNFT",
				address: 0x6c3ff40b90b928ab,
				storage_path: "RCRDSHPNFT.collectionStoragePath",
				public_path: "RCRDSHPNFT.collectionPublicPath",
				public_collection_name: "NonFungibleToken.CollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				RCRDSHPNFT.collectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowNFT(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x8de96244f54db422/contract/SportsIconCollectible
	access(all)
	fun getSportsIconCollectible(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "SportsIconCollectible",
				address: 0x8de96244f54db422,
				storage_path: "SportsIconCollectible.CollectionStoragePath",
				public_path: "SportsIconCollectible.CollectionPublicPath",
				public_collection_name: "SportsIconCollectible.CollectibleCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{SportsIconCollectible.CollectibleCollectionPublic}>(
				SportsIconCollectible.CollectionPublicPath
			).borrow<&{SportsIconCollectible.CollectibleCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let collectible = (col!).borrowCollectible(id: id)
		let nft = (col!).borrowNFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setData = SportsIconCollectible.getSetMetadataForNFTByUUID(uuid: (nft!).uuid)!
		let editionData = SportsIconCollectible.getCollectibleDataForNftByUUID(uuid: (nft!).uuid)!
		let setMetadata = setData.getMetadata()
		let rawMetadata:{ String: String?} ={} 
		for key in setMetadata.keys{ 
			rawMetadata.insert(key: key, setMetadata[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: setMetadata["title"],
			description: setMetadata["description"],
			external_domain_view_url: "https://app.sportsicon.com/collectible/".concat(
				editionData.getSetID().toString()
			).concat("/").concat(editionData.getEditionNumber().toString()),
			token_uri: nil,
			media: [NFTMedia(uri: (setMetadata!)["contentURL"], mimetype: "video/mp4")],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x5b82f21c0edf76e3/contract/StarlyCard
	access(all)
	fun getStarlyCard(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "StarlyCard",
				address: 0x5b82f21c0edf76e3,
				storage_path: "StarlyCard.CollectionStoragePath",
				public_path: "StarlyCard.CollectionPublicPath",
				public_collection_name: "StarlyCard.StarlyCardCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{StarlyCard.StarlyCardCollectionPublic}>(
				StarlyCard.CollectionPublicPath
			).borrow<&{StarlyCard.StarlyCardCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowStarlyCard(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata:{ "id": (nft!).starlyID}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x98c9c2e548b84d31/contract/CaaPass
	access(all)
	fun getCaaPass(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "CaaPass",
				address: 0x98c9c2e548b84d31,
				storage_path: "CaaPass.CollectionStoragePath",
				public_path: "CaaPass.CollectionPublicPath",
				public_collection_name: "CaaPass.CollectionPublic",
				external_domain: "thing.fund"
			)
		let col =
			owner.capabilities.get<&{CaaPass.CollectionPublic}>(CaaPass.CollectionPublicPath)
				.borrow<&{CaaPass.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCaaPass(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata: CaaPass.Metadata? = (nft!).getMetadata()
		if metadata == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (metadata!).name,
			description: (metadata!).description,
			external_domain_view_url: "https://thing.fund/",
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "ipfs://".concat((metadata!).mediaHash),
					mimetype: (metadata!).mediaType
				)
			],
			metadata:{ 
				"name": (metadata!).name,
				"description": (metadata!).description,
				"mediaType": (metadata!).mediaType,
				"mediaHash": (metadata!).mediaHash
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x0d9bc5af3fc0c2e3/contract/TuneGO
	access(all)
	fun getTuneGO(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "TuneGO",
				address: 0x0d9bc5af3fc0c2e3,
				storage_path: "TuneGO.CollectionStoragePath",
				public_path: "TuneGO.CollectionPublicPath",
				public_collection_name: "TuneGO.TuneGOCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{TuneGO.TuneGOCollectionPublic}>(TuneGO.CollectionPublicPath)
				.borrow<&{TuneGO.TuneGOCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCollectible(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x2d2750f240198f91/contract/MatrixWorldFlowFestNFT
	access(all)
	fun getMatrixWorldFlowFest(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "MatrixWorldFlowFestNFT",
				address: 0x2d2750f240198f91,
				storage_path: "MatrixWorldFlowFestNFT.CollectionStoragePath",
				public_path: "MatrixWorldFlowFestNFT.CollectionPublicPath",
				public_collection_name: "MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic",
				external_domain: "matrixworld.org"
			)
		let col =
			owner.capabilities.get<
				&{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}
			>(MatrixWorldFlowFestNFT.CollectionPublicPath).borrow<
				&{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}
			>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowVoucher(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).metadata.name,
			description: (nft!).metadata.description,
			external_domain_view_url: "matrixworld.org",
			token_uri: nil,
			media: [NFTMedia(uri: (nft!).metadata.animationUrl, mimetype: "image")],
			metadata:{ "type": (nft!).metadata.type, "hash": (nft!).metadata.hash}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x0b2a3299cc857e29/contract/TopShot
	access(all)
	fun getTopShot(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "TopShot",
				address: 0x0b2a3299cc857e29,
				storage_path: "/storage/MomentCollection",
				public_path: "/public/MomentCollection",
				public_collection_name: "TopShot.MomentCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
				.borrow<&{TopShot.MomentCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowMoment(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = TopShot.getPlayMetaData(playID: (nft!).data.playID)!
		let rawMetadata:{ String: String?} ={} 
		for key in metadata.keys{ 
			rawMetadata.insert(key: key, metadata[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: metadata["FullName"],
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x233eb012d34b0070/contract/Domains
	access(all)
	fun getFlownsDomain(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "FlownsDomain",
				address: 0x233eb012d34b0070,
				storage_path: "Domains.CollectionStoragePath",
				public_path: "Domains.CollectionPublicPath",
				public_collection_name: "Domains.CollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{Domains.CollectionPublic}>(Domains.CollectionPublicPath)
				.borrow<&{Domains.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowDomain(id: id)
		if nft == nil{ 
			return nil
		}
		let name = (nft!).getDomainName()
		let URI = "https://www.flowns.org/api/fns?domain=".concat(name)
		let viewURL = "https://www.flowns.org/api/data?domain=".concat(name)
		let rawMetadata:{ String: String?} ={} 
		for key in (nft!).getAllTexts().keys{ 
			rawMetadata.insert(key: key, (nft!).getAllTexts()[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: name,
			description: nil,
			external_domain_view_url: viewURL,
			token_uri: nil,
			media: [NFTMedia(uri: URI, mimetype: "image")],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x81e95660ab5308e1/contract/TFCItems
	access(all)
	fun getTFCItems(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "TFCItems",
				address: 0x81e95660ab5308e1,
				storage_path: "/storage/TFCItemsCollection",
				public_path: "/public/TFCItemsCollection",
				public_collection_name: "TFCItem.TFCItemsCollectionPublic",
				external_domain: ""
			)
		let col =
			(
				owner.capabilities.get<&{TFCItems.TFCItemsCollectionPublic}>(
					TFCItems.CollectionPublicPath
				)!
			).borrow()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowTFCItem(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = (nft!).getMetadata()
		let rawMetadata:{ String: String?} ={} 
		for key in (metadata!).keys{ 
			rawMetadata.insert(key: key, (metadata!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: metadata["Title"]!,
			description: nil,
			external_domain_view_url: "thefootballclub.com",
			token_uri: nil,
			media: [NFTMedia(uri: metadata["URL"]!, mimetype: "image")],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x34f2bf4a80bb0f69/contract/GooberXContract
	access(all)
	fun getGooberz(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "GooberXContract",
				address: 0x34f2bf4a80bb0f69,
				storage_path: "GooberXContract.CollectionStoragePath",
				public_path: "GooberXContract.CollectionPublicPath",
				public_collection_name: "GooberXContract.GooberCollectionPublic",
				external_domain: "partymansion.io"
			)
		let col =
			owner.capabilities.get<&{GooberXContract.GooberCollectionPublic}>(
				GooberXContract.CollectionPublicPath
			).borrow<&{GooberXContract.GooberCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowGoober(id: id)
		if nft == nil{ 
			return nil
		}
		let title = "Goober #".concat((nft!).id.toString())
		let description = "Goober living in the party mansion"
		let external_domain_view_url =
			"https://partymansion.io/gooberz/".concat((nft!).id.toString())
		let rawMetadata:{ String: String?} ={} 
		for key in (((nft!).data!).metadata!).keys{ 
			if ((((nft!).data!).metadata!)[key]!).getType().isSubtype(of: Type<Number>()){ 
				rawMetadata.insert(key: key, ((((nft!).data!).metadata!)[key]! as! Number).toString())
			} else if ((((nft!).data!).metadata!)[key]!).getType().isSubtype(of: Type<String>()){ 
				rawMetadata.insert(key: key, (((nft!).data!).metadata!)[key]! as! String)
			}
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: title,
			description: description,
			external_domain_view_url: external_domain_view_url,
			token_uri: nil,
			media: [NFTMedia(uri: ((nft!).data!).uri, mimetype: "image")],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x20187093790b9aef/contract/MintStoreItem
	// https://flow-view-source.com/testnet/account/0x985d410b577fd4a1/contract/MintStoreItem
	access(all)
	fun getMintStoreItem(owner: &Account, id: UInt64): NFTData?{ 
		let col =
			owner.capabilities.get<&{MintStoreItem.MintStoreItemCollectionPublic}>(
				MintStoreItem.CollectionPublicPath
			).borrow<&{MintStoreItem.MintStoreItemCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowMintStoreItem(id: id)
		if nft == nil{ 
			return nil
		}
		let editionData = MintStoreItem.EditionData(editionID: (nft!).data.editionID)!
		let description = (editionData!).metadata["description"]!
		let merchantName = MintStoreItem.getMerchant(merchantID: (nft!).data.merchantID)!
		var external_domain = ""
		switch merchantName{ 
			case "Bulls":
				external_domain = "https://bulls.mint.store"
				break
			case "Charlotte Hornets":
				external_domain = "https://hornets.mint.store"
				break
			default:
				external_domain = ""
		}
		if (editionData!).metadata["nftType"]! == "Type C"{ 
			external_domain = "https://misa.art/collections/nft"
		}
		let _contract =
			NFTContractData(
				name: merchantName,
				address: 0x985d410b577fd4a1,
				storage_path: "MintStoreItem.CollectionStoragePath",
				public_path: "MintStoreItem.CollectionPublicPath",
				public_collection_name: "MintStoreItem.MintStoreItemCollectionPublic",
				external_domain: external_domain
			)
		let rawMetadata:{ String: String?} ={
			
				"merchantID": (nft!).data.merchantID.toString(),
				"merchantName": merchantName,
				"editionID": (editionData!).editionID.toString(),
				"numberOfItemsMinted": (editionData!).numberOfItemsMinted.toString(),
				"printingLimit": ((editionData!).printingLimit!).toString(),
				"editionNumber": (nft!).data.editionNumber.toString(),
				"description": (editionData!).metadata["description"]!,
				"name": (editionData!).metadata["name"]!,
				"nftType": (editionData!).metadata["nftType"]!,
				"editionCount": ((editionData!).printingLimit!).toString(),
				"royaltyAddress": (editionData!).metadata["royaltyAddress"],
				"royaltyPercentage": (editionData!).metadata["royaltyPercentage"]
			}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: editionData.name,
			description: description,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [
				NFTMedia(
					uri: (editionData!).metadata["mediaURL"],
					mimetype: (editionData!).metadata["mimetype"]
				)
			],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x7859c48816bfea3c/contract/BnGNFT
	access(all)
	fun getBiscuitsNGroovy(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "BnGNFT",
				address: 0x7859c48816bfea3c,
				storage_path: "BnGNFT.CollectionStoragePath",
				public_path: "BnGNFT.CollectionPublicPath",
				public_collection_name: "BnGNFT.BnGNFTCollectionPublic",
				external_domain: "www.bngroovy.com"
			)
		let col =
			owner.capabilities.get<&{BnGNFT.BnGNFTCollectionPublic}>(BnGNFT.CollectionPublicPath)
				.borrow<&{BnGNFT.BnGNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowBnGNFT(id: id)
		if nft == nil{ 
			return nil
		}
		let rawMetadata:{ String: String?} ={} 
		for key in ((nft!).metadata!).keys{ 
			rawMetadata.insert(key: key, ((nft!).metadata!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: ((nft!).metadata!)["metadata_url"],
			token_uri: nil,
			media: [],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xabda6627c70c7f52/contract/GeniaceNFT
	access(all)
	fun getGeniaceNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Geniace",
				address: 0xabda6627c70c7f52,
				storage_path: "GeniaceNFT.CollectionStoragePath",
				public_path: "GeniaceNFT.CollectionPublicPath",
				public_collection_name: "GeniaceNFT.GeniaceNFTCollectionPublic",
				external_domain: "https://www.geniace.com/"
			)
		let col =
			owner.capabilities.get<&{GeniaceNFT.GeniaceNFTCollectionPublic}>(
				GeniaceNFT.CollectionPublicPath
			).borrow<&{GeniaceNFT.GeniaceNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowGeniaceNFT(id: id)
		if nft == nil{ 
			return nil
		}
		fun getNFTMedia(): [NFTMedia?]{ 
			if (((nft!).metadata!).data!)["mimetype"] == nil{ 
				return []
			} else{ 
				return [NFTMedia(uri: ((nft!).metadata!).imageUrl, mimetype: (((nft!).metadata!).data!)["mimetype"])]
			}
		}
		fun getRarity(): String?{ 
			switch (nft!).metadata.rarity{ 
				case GeniaceNFT.Rarity.Collectible:
					return "Collectible"
				case GeniaceNFT.Rarity.Rare:
					return "Rare"
				case GeniaceNFT.Rarity.UltraRare:
					return "UltraRare"
				default:
					return ""
			}
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: ((nft!).metadata!).name,
			description: ((nft!).metadata!).description,
			external_domain_view_url: "https://www.geniace.com/product/".concat(
				(nft!).id.toString()
			),
			token_uri: nil,
			media: getNFTMedia(),
			metadata:{ 
				"celebrityName": ((nft!).metadata!).celebrityName,
				"artist": ((nft!).metadata!).artist,
				"rarity": getRarity()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xf5b0eb433389ac3f/contract/Collectible
	access(all)
	fun getXtinglesNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Xtingles",
				address: 0xf5b0eb433389ac3f,
				storage_path: "Collectible.CollectionStoragePath",
				public_path: "Collectible.CollectionPublicPath",
				public_collection_name: "Collectible.CollectionPublicPath",
				external_domain: "https://www.xtingles.com/"
			)
		let col =
			owner.capabilities.get<&{Collectible.CollectionPublic}>(
				Collectible.CollectionPublicPath
			).borrow<&{Collectible.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCollectible(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: nil,
			title: ((nft!).metadata!).name,
			description: ((nft!).metadata!).description,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [NFTMedia(uri: ((nft!).metadata!).link, mimetype: "video")],
			metadata:{ 
				"author": ((nft!).metadata!).author,
				"edition": ((nft!).metadata!).edition.toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x8ea44ab931cac762
	access(all)
	fun getInceptionAnimals(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "InceptionAnimals",
				address: 0x8ea44ab931cac762,
				storage_path: "CryptoZooNFT.CollectionStoragePath",
				public_path: "CryptoZooNFT.CollectionPublicPath",
				public_collection_name: "CryptoZooNFT.CryptoZooNFTCollectionPublic",
				external_domain: "https://www.inceptionanimals.com/"
			)
		let col =
			owner.capabilities.get<&{CryptoZooNFT.CryptoZooNFTCollectionPublic}>(
				CryptoZooNFT.CollectionPublicPath
			).borrow<&{CryptoZooNFT.CryptoZooNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCryptoZooNFT(id: id)
		if nft == nil{ 
			return nil
		}
		let rawMetadata:{ String: String?} ={} 
		for key in (((nft!).getNFTTemplate()!).getMetadata()!).keys{ 
			rawMetadata.insert(key: key, (((nft!).getNFTTemplate()!).getMetadata()!)[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name,
			description: ((nft!).getNFTTemplate()!).description,
			external_domain_view_url: nil,
			token_uri: ((nft!).getNFTTemplate()!).getMetadata()["uri"]!,
			media: [
				NFTMedia(
					uri: ((nft!).getNFTTemplate()!).getMetadata()["uri"]!,
					mimetype: ((nft!).getNFTTemplate()!).getMetadata()["mimetype"]!
				)
			],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible
	access(all)
	fun getOneFootballCollectible(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "OneFootballCollectible",
				address: 0x6831760534292098,
				storage_path: "OneFootballCollectible.CollectionStoragePath",
				public_path: "OneFootballCollectible.CollectionPublicPath",
				public_collection_name: "OneFootballCollectible.OneFootballCollectibleCollectionPublic",
				external_domain: "http://xmas.onefootball.com/"
			)
		if let collection =
			owner.capabilities.get<&OneFootballCollectible.Collection>(
				OneFootballCollectible.CollectionPublicPath
			).borrow(){ 
			if let nft = collection.borrowOneFootballCollectible(id: id){ 
				if let metadata = nft.getTemplate(){ 
					return NFTData(_contract: _contract, id: nft.id, uuid: nft.uuid, title: metadata.name, description: metadata.description, external_domain_view_url: "https://xmas.onefootball.com/".concat(owner.address.toString()), token_uri: nil, media: [																																																																  // media
																																																																  NFTMedia(uri: "https://".concat(metadata.media).concat(".ipfs.dweb.link/"), mimetype: "video"),																																																																																								  // preview
																																																																																								  NFTMedia(uri: "https://".concat(metadata.preview).concat(".ipfs.dweb.link/"), mimetype: "image")], metadata:{ "of_id": metadata.data["of_id"], "player_name": metadata.data["player_name"]})
				}
			}
		}
		return nil
	}
	
	// https://flow-view-source.com/mainnet/account/0xa0cbe021821c0965/contract/TheFabricantMysteryBox_FF1
	access(all)
	fun getTheFabricantMysteryBox_FF1(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "TheFabricantMysteryBox_FF1",
				address: 0xa0cbe021821c0965,
				storage_path: "/storage/FabricantCollection001",
				public_path: "/public/FabricantCollection001",
				public_collection_name: "TheFabricantMysteryBox_FF1.FabricantCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{TheFabricantMysteryBox_FF1.FabricantCollectionPublic}>(
				/public/FabricantCollection001
			).borrow<&{TheFabricantMysteryBox_FF1.FabricantCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowFabricant(id: id)!
		if nft == nil{ 
			return nil
		}
		let dataID = nft.fabricant.fabricantDataID
		let fabricantData = TheFabricantMysteryBox_FF1.getFabricantData(id: dataID)
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [NFTMedia(uri: fabricantData.mainImage, mimetype: "image")],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x497153c597783bc3/contract/DieselNFT
	access(all)
	fun getDieselNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "DieselNFT",
				address: 0x497153c597783bc3,
				storage_path: "/storage/DieselCollection001",
				public_path: "/public/DieselCollection001",
				public_collection_name: "DieselNFT.DieselCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{DieselNFT.DieselCollectionPublic}>(/public/DieselCollection001)
				.borrow<&{DieselNFT.DieselCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowDiesel(id: id)!
		if nft == nil{ 
			return nil
		}
		let dataID = nft.diesel.dieselDataID
		let dieselData = DieselNFT.getDieselData(id: dataID)
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: dieselData.name,
			description: dieselData.description,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [NFTMedia(uri: dieselData.mainVideo, mimetype: "video")],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x429a19abea586a3e/contract/MiamiNFT
	access(all)
	fun getMiamiNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "MiamiNFT",
				address: 0x429a19abea586a3e,
				storage_path: "/storage/MiamiCollection001",
				public_path: "/public/MiamiCollection001",
				public_collection_name: "MiamiNFT.MiamiCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{MiamiNFT.MiamiCollectionPublic}>(/public/MiamiCollection001)
				.borrow<&{MiamiNFT.MiamiCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowMiami(id: id)!
		if nft == nil{ 
			return nil
		}
		let dataID = nft.miami.miamiDataID
		let miamiData = MiamiNFT.getMiamiData(id: dataID)
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: miamiData.name,
			description: miamiData.description,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [NFTMedia(uri: miamiData.mainVideo, mimetype: "video")],
			metadata:{ "creator": miamiData.creator.toString(), "season": miamiData.season}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xf61e40c19db2a9e2/contract/HaikuNFT
	access(all)
	fun getBitku(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Bitku",
				address: 0xf61e40c19db2a9e2,
				storage_path: "/storage/BitkuCollection",
				public_path: "/public/BitkuCollection",
				public_collection_name: "HaikuNFT.HaikuCollectionPublic",
				external_domain: "bitku.art"
			)
		let col =
			owner.capabilities.get<&{HaikuNFT.HaikuCollectionPublic}>(
				HaikuNFT.HaikuCollectionPublicPath
			).borrow<&{HaikuNFT.HaikuCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowHaiku(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: nil,
			title: nil,
			description: (nft!).text,
			external_domain_view_url: "https://bitku.art/#".concat(owner.address.toString()).concat(
				"/"
			).concat((nft!).id.toString()),
			token_uri: nil,
			media: [],
			metadata:{ "text": (nft!).text}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x99fed1e8da4c3431/contract/FlowChinaBadge
	access(all)
	fun getFlowFansNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "FlowFans",
				address: 0x99fed1e8da4c3431,
				storage_path: "/storage/FlowChinaBadgeCollection",
				public_path: "/public/FlowChinaBadgeCollection",
				public_collection_name: "FlowChinaBadge.FlowChinaBadgeCollectionPublic",
				external_domain: "https://twitter.com/FlowFansChina"
			)
		let col =
			owner.capabilities.get<&{FlowChinaBadge.FlowChinaBadgeCollectionPublic}>(
				/public/FlowChinaBadgeCollection
			).borrow<&{FlowChinaBadge.FlowChinaBadgeCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowFlowChinaBadge(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: (nft!).metadata,
			media: [],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xe4cf4bdc1751c65d/contract/AllDay
	access(all)
	fun getAllDay(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "AllDay",
				address: 0xe4cf4bdc1751c65d,
				storage_path: "AllDay.CollectionStoragePath",
				public_path: "AllDay.CollectionPublicPath",
				public_collection_name: "AllDay.MomentNFTCollectionPublic",
				external_domain: "https://nflallday.com/"
			)
		let col =
			owner.capabilities.get<&{AllDay.MomentNFTCollectionPublic}>(AllDay.CollectionPublicPath)
				.borrow<&{AllDay.MomentNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowMomentNFT(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: nil,
			title: "Moment".concat((nft!).id.toString()).concat("-Edition").concat(
				(nft!).editionID.toString()
			).concat("-SerialNumber").concat((nft!).serialNumber.toString()),
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xe4cf4bdc1751c65d/contract/PackNFT
	access(all)
	fun getAllDayPackNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "PackNFT",
				address: 0xe4cf4bdc1751c65d,
				storage_path: "PackNFT.CollectionStoragePath",
				public_path: "PackNFT.CollectionPublicPath",
				public_collection_name: "NonFungibleToken.CollectionPublic",
				external_domain: "https://nflallday.com/"
			)
		let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				PackNFT.CollectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowNFT(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: nil,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xfc91de5e6566cc7c/contract/ItemNFT
	access(all)
	fun getItemNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "ItemNFT",
				address: 0xfc91de5e6566cc7c,
				storage_path: "ItemNFT.CollectionStoragePath",
				public_path: "ItemNFT.CollectionPublicPath",
				public_collection_name: "ItemNFT.ItemCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{ItemNFT.ItemCollectionPublic}>(ItemNFT.CollectionPublicPath)
				.borrow<&{ItemNFT.ItemCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowItem(id: id)!
		if nft == nil{ 
			return nil
		}
		let itemDataID = nft.item.itemDataID
		let itemData = ItemNFT.getItemData(id: itemDataID)
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [
				NFTMedia(uri: itemData.mainImage, mimetype: "image"),
				NFTMedia(uri: itemData.images[0], mimetype: "image"),
				NFTMedia(uri: itemData.images[1], mimetype: "image"),
				NFTMedia(uri: itemData.images[2], mimetype: "image"),
				NFTMedia(uri: itemData.images[3], mimetype: "image")
			],
			metadata:{ "name": (nft!).name}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x9e03b1f871b3513/contract/TheFabricantS1ItemNFT
	access(all)
	fun getTheFabricantS1ItemNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "TheFabricantS1ItemNFT",
				address: 0x9e03b1f871b3513,
				storage_path: "TheFabricantS1ItemNFT.CollectionStoragePath",
				public_path: "TheFabricantS1ItemNFT.CollectionPublicPath",
				public_collection_name: "TheFabricantS1ItemNFT.ItemCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{TheFabricantS1ItemNFT.ItemCollectionPublic}>(
				TheFabricantS1ItemNFT.CollectionPublicPath
			).borrow<&{TheFabricantS1ItemNFT.ItemCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowItem(id: id)!
		if nft == nil{ 
			return nil
		}
		let itemDataID = nft.item.itemDataID
		let itemData = TheFabricantS1ItemNFT.getItemData(id: itemDataID)
		let itemMetadata = itemData.getMetadata()
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [
				NFTMedia(uri: (itemMetadata["itemVideo"]!).metadataValue, mimetype: "video"),
				NFTMedia(uri: (itemMetadata["itemImage"]!).metadataValue, mimetype: "image")
			],
			metadata:{ 
				"name": (nft!).name,
				"primaryColor": (itemMetadata["primaryColor"]!).metadataValue,
				"secondaryColor": (itemMetadata["secondaryColor"]!).metadataValue,
				"coCreator": itemData.coCreator.toString(),
				"season": (itemMetadata["season"]!).metadataValue
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x62b3063fbe672fc8/contract/ZeedzINO
	access(all)
	fun getZeedzINO(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "ZeedzINO",
				address: 0x62b3063fbe672fc8,
				storage_path: "/storage/ZeedzINOCollection",
				public_path: "/public/ZeedzINOCollection",
				public_collection_name: "ZeedzINO.ZeedzCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{ZeedzINO.ZeedzCollectionPublic}>(/public/ZeedzINOCollection)
				.borrow<&{ZeedzINO.ZeedzCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowZeedle(id: id)!
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name,
			description: (nft!).description,
			external_domain_view_url: "https:/www.zeedz.io",
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://zeedz.mypinata.cloud/ipfs/".concat((nft!).imageURI),
					mimetype: "image"
				)
			],
			metadata:{ 
				"typeID": (nft!).typeID.toString(),
				"evoultionStage": (nft!).evolutionStage.toString(),
				"serialNumber": (nft!).serialNumber,
				"editionNumber": (nft!).edition.toString(),
				"editionCount": (nft!).editionCap.toString(),
				"rarity": (nft!).rarity,
				"carbonOffset": (nft!).carbonOffset.toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xf3cc54f4d91c2f6c/contract/Kicks
	access(all)
	fun getKicksSneaker(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "ClosedSrc - NFTLX",
				address: 0xf3cc54f4d91c2f6c,
				storage_path: "Kicks.CollectionStoragePath",
				public_path: "Kicks.CollectionPublicPath",
				public_collection_name: "Kicks.KicksCollectionPublic",
				external_domain: "https://www.nftlx.io/closedSrc"
			)
		let col =
			owner.capabilities.get<&{Kicks.KicksCollectionPublic}>(Kicks.CollectionPublicPath)
				.borrow<&{Kicks.KicksCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowSneaker(id: id)
		if nft == nil{ 
			return nil
		}
		let rawMetadata = (nft!).getMetadata()
		var metadata:{ String: String?} ={} 
		var media: [NFTMedia] = []
		let description =
			(nft!).setID == 0 ? "Union Jordan 4 'Off Noir' x Nike Dunk" : (nft!).description()
		if let mediaValue = metadata["media"]{ 
			if let supportedMedia = mediaValue as?{ String: [String]}{ 
				for mediaType in supportedMedia.keys{ 
					for mediaURI in supportedMedia[mediaType]!{ 
						media.append(NFTMedia(uri: mediaURI, mimetype: mediaType))
					}
				}
			}
		}
		for key in rawMetadata.keys{ 
			if (rawMetadata[key]!).getType().isSubtype(of: Type<String>()){ 
				metadata[key] = rawMetadata[key]! as! String
			} else if (rawMetadata[key]!).getType().isSubtype(of: Type<Number>()){ 
				metadata[key] = (rawMetadata[key]! as! Number).toString()
			} else if (rawMetadata[key]!).getType() != Type<String>(){ 
				metadata.remove(key: key)
			}
		}
		if !metadata.containsKey("editionNumber"){ 
			metadata["editionNumber"] = (nft!).setID == 0 ? (nft!).id.toString() : (nft!).instanceID.toString()
		}
		if !metadata.containsKey("editionCount"){ 
			metadata["editionCount"] = (Kicks.getSneakerSet(withID: (nft!).setID)!).getTotalSupply().toString()
		}
		if !metadata.containsKey("royaltyAddress"){ 
			metadata["royaltyAddress"] = "0xf3cc54f4d91c2f6c"
		}
		if !metadata.containsKey("royaltyPercentage"){ 
			metadata["royaltyPercentage"] = "5"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name(),
			description: description,
			external_domain_view_url: "https://www.nftlx.io/nft/".concat((nft!).id.toString()),
			token_uri: nil,
			media: media,
			metadata: metadata
		)
	}
	
	access(all)
	fun getBarterYardPack(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "BarterYardPack",
				address: 0xa95b021cf8a30d80,
				storage_path: "BarterYardPackNFT.CollectionStoragePath",
				public_path: "BarterYardPackNFT.CollectionPublicPath",
				public_collection_name: "BarterYardPackNFT.BarterYardPackNFTCollectionPublic",
				external_domain: "https://barteryard.club"
			)
		let collection =
			owner.capabilities.get<&{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}>(
				BarterYardPackNFT.CollectionPublicPath
			).borrow<&{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}>()!
		if collection == nil{ 
			return nil
		}
		let nft = collection.borrowBarterYardPackNFT(id: id)!
		// Get the basic display information for this NFT
		let view = nft.resolveView(Type<MetadataViews.Display>())!
		let display = view as! MetadataViews.Display
		let ipfsFile = display.thumbnail as! MetadataViews.IPFSFile
		let packPartView = nft.resolveView(Type<BarterYardPackNFT.PackMetadataDisplay>())!
		let packMetadata = packPartView as! BarterYardPackNFT.PackMetadataDisplay
		let edition = packMetadata.edition
		return NFTData(
			_contract: _contract,
			id: id,
			uuid: nil,
			title: display.name.concat(" #").concat(edition.toString()),
			description: display.description,
			external_domain_view_url: "https://barteryard.club/nft/".concat(id.toString()),
			token_uri: nil,
			media: [NFTMedia(uri: "https://ipfs.io/ipfs/".concat(ipfsFile.cid), mimetype: "image")],
			metadata:{ "pack": display.name}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x1600b04bf033fb99/contract/DayNFT
	access(all)
	fun getDayNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "DayNFT",
				address: 0x1600b04bf033fb99,
				storage_path: "DayNFT.CollectionStoragePath",
				public_path: "DayNFT.CollectionPublicPath",
				public_collection_name: "DayNFT.CollectionPublic",
				external_domain: "https://day-nft.io"
			)
		let col =
			owner.capabilities.get<&{DayNFT.CollectionPublic}>(DayNFT.CollectionPublicPath).borrow<
				&{DayNFT.CollectionPublic}
			>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowDayNFT(id: id)!
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name,
			description: (nft!).description,
			external_domain_view_url: (nft!).thumbnail,
			token_uri: nil,
			media: [NFTMedia(uri: (nft!).thumbnail, mimetype: "image")],
			metadata:{ 
				"name": (nft!).name,
				"message": (nft!).title,
				"description": (nft!).description,
				"thumbnail": (nft!).thumbnail,
				"date": (nft!).dateStr,
				"editionNumber": "1",
				"editionCount": "1",
				"royaltyAddress": "0x1600b04bf033fb99",
				"royaltyPercentage": "5.0"
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/Costacos_NFT
	access(all)
	fun getCostacosNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Costacos_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "Costacos_NFT.CollectionStoragePath",
				public_path: "Costacos_NFT.CollectionPublicPath",
				public_collection_name: "Costacos_NFT.Costacos_NFT",
				external_domain: "https://costacoscollection.com/"
			)
		let col =
			owner.capabilities.get<&{Costacos_NFT.Costacos_NFTCollectionPublic}>(
				Costacos_NFT.CollectionPublicPath
			).borrow<&{Costacos_NFT.Costacos_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCostacos_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = Costacos_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			Costacos_NFT.getSeriesMetadata(
				seriesId: Costacos_NFT.getSetSeriesId(setId: (nft!).setId)!
			)
		let seriesId = Costacos_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = Costacos_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			"https://shop.costacoscollection.com/tokens/".concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/Canes_Vault_NFT
	access(all)
	fun getCanesVaultNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Canes_Vault_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "Canes_Vault_NFT.CollectionStoragePath",
				public_path: "Canes_Vault_NFT.CollectionPublicPath",
				public_collection_name: "Canes_Vault_NFT.Canes_Vault_NFT",
				external_domain: "https://www.canesvault.com/"
			)
		let col =
			owner.capabilities.get<&{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}>(
				Canes_Vault_NFT.CollectionPublicPath
			).borrow<&{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCanes_Vault_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = Canes_Vault_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			Canes_Vault_NFT.getSeriesMetadata(
				seriesId: Canes_Vault_NFT.getSetSeriesId(setId: (nft!).setId)!
			)
		let seriesId = Canes_Vault_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = Canes_Vault_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			((setMeta!)["external_url"]!).concat("/tokens/").concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/AmericanAirlines_NFT
	access(all)
	fun getAmericanAirlinesNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "AmericanAirlines_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "AmericanAirlines_NFT.CollectionStoragePath",
				public_path: "AmericanAirlines_NFT.CollectionPublicPath",
				public_collection_name: "AmericanAirlines_NFT.AmericanAirlines_NFT",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{AmericanAirlines_NFT.AmericanAirlines_NFTCollectionPublic}>(
				AmericanAirlines_NFT.CollectionPublicPath
			).borrow<&{AmericanAirlines_NFT.AmericanAirlines_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowAmericanAirlines_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = AmericanAirlines_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			AmericanAirlines_NFT.getSeriesMetadata(
				seriesId: AmericanAirlines_NFT.getSetSeriesId(setId: (nft!).setId)!
			)
		let seriesId = AmericanAirlines_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = AmericanAirlines_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			"https://americanairlines.nftbridge.com/tokens/".concat((nft!).id.toString())
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: (setMeta!)["image_file_type"]),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/The_Next_Cartel_NFT
	access(all)
	fun getTheNextCartelNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "The_Next_Cartel_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "The_Next_Cartel_NFT.CollectionStoragePath",
				public_path: "The_Next_Cartel_NFT.CollectionPublicPath",
				public_collection_name: "The_Next_Cartel_NFT.The_Next_Cartel_NFT",
				external_domain: "https://thenextcartel.com/nft-store"
			)
		let col =
			owner.capabilities.get<&{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}>(
				The_Next_Cartel_NFT.CollectionPublicPath
			).borrow<&{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowThe_Next_Cartel_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = The_Next_Cartel_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			The_Next_Cartel_NFT.getSeriesMetadata(
				seriesId: The_Next_Cartel_NFT.getSetSeriesId(setId: (nft!).setId)!
			)
		let seriesId = The_Next_Cartel_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = The_Next_Cartel_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			"https://thenextcartel.shops.nftbridge.com/tokens/".concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/Atheletes_Unlimited_NFT
	access(all)
	fun getAthletesUnlimitedNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Atheletes_Unlimited_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "Atheletes_Unlimited_NFT.CollectionStoragePath",
				public_path: "Atheletes_Unlimited_NFT.CollectionPublicPath",
				public_collection_name: "Atheletes_Unlimited_NFT.Atheletes_Unlimited_NFT",
				external_domain: "https://nft.auprosports.com/"
			)
		let col =
			owner.capabilities.get<
				&{Atheletes_Unlimited_NFT.Atheletes_Unlimited_NFTCollectionPublic}
			>(Atheletes_Unlimited_NFT.CollectionPublicPath).borrow<
				&{Atheletes_Unlimited_NFT.Atheletes_Unlimited_NFTCollectionPublic}
			>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowAtheletes_Unlimited_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = Atheletes_Unlimited_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			Atheletes_Unlimited_NFT.getSeriesMetadata(
				seriesId: Atheletes_Unlimited_NFT.getSetSeriesId(setId: (nft!).setId)!
			)
		let seriesId = Atheletes_Unlimited_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = Atheletes_Unlimited_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			"https://nft.auprosports.com/tokens/".concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/Art_NFT
	access(all)
	fun getArtNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Art_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "Art_NFT.CollectionStoragePath",
				public_path: "Art_NFT.CollectionPublicPath",
				public_collection_name: "Art_NFT.Art_NFT",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{Art_NFT.Art_NFTCollectionPublic}>(Art_NFT.CollectionPublicPath)
				.borrow<&{Art_NFT.Art_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowArt_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = Art_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			Art_NFT.getSeriesMetadata(seriesId: Art_NFT.getSetSeriesId(setId: (nft!).setId)!)
		let seriesId = Art_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = Art_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl = "https://art.nftbridge.com/tokens/".concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/DGD_NFT
	access(all)
	fun getDGDNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "DGD_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "DGD_NFT.CollectionStoragePath",
				public_path: "DGD_NFT.CollectionPublicPath",
				public_collection_name: "DGD_NFT.DGD_NFT",
				external_domain: "https://www.theplayerslounge.io/"
			)
		let col =
			owner.capabilities.get<&{DGD_NFT.DGD_NFTCollectionPublic}>(DGD_NFT.CollectionPublicPath)
				.borrow<&{DGD_NFT.DGD_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowDGD_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = DGD_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			DGD_NFT.getSeriesMetadata(seriesId: DGD_NFT.getSetSeriesId(setId: (nft!).setId)!)
		let seriesId = DGD_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = DGD_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			"https://app.theplayerslounge.io/tokens/".concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x8c9bbcdcd7514081/contract/GogoroCollectible
	access(all)
	fun getGogoroCollectibleNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "GogoroCollectible",
				address: 0x8c9bbcdcd7514081,
				storage_path: "GogoroCollectible.CollectionStoragePath",
				public_path: "GogoroCollectible.CollectionPublicPath",
				public_collection_name: "GogoroCollectible.CollectionPublic",
				external_domain: "https://www.gogoro.com/"
			)
		let col =
			owner.capabilities.get<&{GogoroCollectible.CollectionPublic}>(
				GogoroCollectible.CollectionPublicPath
			).borrow<&{GogoroCollectible.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowGogoroCollectible(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = (nft!).getMetadata()!
		let additional = metadata.getAdditional()
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: metadata.name,
			description: metadata.description,
			external_domain_view_url: "https://bay.blocto.app/flow/gogoro/".concat(
				(nft!).id.toString()
			),
			token_uri: nil,
			media: [NFTMedia(uri: additional["mediaUrl"]!, mimetype: metadata.mediaType)],
			metadata:{ 
				"rarity": additional["rarity"]!,
				"editionNumber": (nft!).editionNumber.toString(),
				"editionCount": metadata.itemCount.toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x758252ab932a3416/contract/YahooCollectible
	access(all)
	fun getYahooCollectibleNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "YahooCollectible",
				address: 0x758252ab932a3416,
				storage_path: "YahooCollectible.CollectionStoragePath",
				public_path: "YahooCollectible.CollectionPublicPath",
				public_collection_name: "YahooCollectible.CollectionPublic",
				external_domain: "https://tw.yahoo.com/"
			)
		let col =
			owner.capabilities.get<&{YahooCollectible.CollectionPublic}>(
				YahooCollectible.CollectionPublicPath
			).borrow<&{YahooCollectible.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowYahooCollectible(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = (nft!).getMetadata()!
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: metadata.name,
			description: metadata.description,
			external_domain_view_url: "https://bay.blocto.app/flow/yahoo/".concat(
				(nft!).id.toString()
			),
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://ipfs.io/ipfs/".concat(metadata.mediaHash),
					mimetype: metadata.mediaType
				)
			],
			metadata:{ 
				"rarity": metadata.getAdditional()["rarity"]!,
				"editionNumber": (nft!).editionNumber.toString(),
				"editionCount": metadata.itemCount.toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x758252ab932a3416/contract/YahooPartnersCollectible
	access(all)
	fun getYahooPartnersCollectibleNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "YahooPartnersCollectible",
				address: 0x758252ab932a3416,
				storage_path: "YahooPartnersCollectible.CollectionStoragePath",
				public_path: "YahooPartnersCollectible.CollectionPublicPath",
				public_collection_name: "YahooPartnersCollectible.CollectionPublic",
				external_domain: "https://tw.yahoo.com/"
			)
		let col =
			owner.capabilities.get<&{YahooPartnersCollectible.CollectionPublic}>(
				YahooPartnersCollectible.CollectionPublicPath
			).borrow<&{YahooPartnersCollectible.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowYahooPartnersCollectible(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = (nft!).getMetadata()!
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: metadata.name,
			description: metadata.description,
			external_domain_view_url: "https://bay.blocto.app/flow/yahoo-partners/".concat(
				(nft!).id.toString()
			),
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://ipfs.io/ipfs/".concat(metadata.mediaHash),
					mimetype: metadata.mediaType
				)
			],
			metadata:{ 
				"rarity": metadata.getAdditional()["rarity"]!,
				"editionNumber": (nft!).editionNumber.toString(),
				"editionCount": metadata.itemCount.toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x85b8bbf926dcddfa/contract/NowggNFT
	access(all)
	fun getNowggNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "NowggNFT",
				address: 0x85b8bbf926dcddfa,
				storage_path: "NowggNFT.CollectionStoragePath",
				public_path: "NowggNFT.CollectionPublicPath",
				public_collection_name: "NowggNFT.NowggNFTCollectionPublic",
				external_domain: "https://nft.now.gg/"
			)
		let col =
			owner.capabilities.get<&{NowggNFT.NowggNFTCollectionPublic}>(
				NowggNFT.CollectionPublicPath
			).borrow<&{NowggNFT.NowggNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowNowggNFT(id: id)
		if nft == nil{ 
			return nil
		}
		let nftInfo = nft!
		let metadata = nftInfo.getMetadata()!
		let nftTypeId = metadata["nftTypeId"]! as! String
		let externalViewUrl = "https://nft.now.gg/nft/".concat(nftTypeId)
		return NFTData(
			_contract: _contract,
			id: nftInfo.id,
			uuid: nftInfo.uuid,
			title: metadata["title"]! as? String,
			description: metadata["description"]! as? String,
			external_domain_view_url: externalViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(
					uri: metadata["displayUrl"]! as? String,
					mimetype: metadata["displayUrlMediaType"]! as? String
				),
				NFTMedia(
					uri: metadata["contentUrl"]! as? String,
					mimetype: metadata["contentType"]! as? String
				)
			],
			metadata:{ 
				"clientName": metadata["clientName"]! as? String,
				"nftTypeId": metadata["nftTypeId"]! as? String,
				"creatorName": metadata["creatorName"]! as? String,
				"clientId": metadata["clientId"]! as? String,
				"maxCount": ((metadata["maxCount"]! as? UInt64)!).toString(),
				"copyNumber": ((metadata["copyNumber"]! as? UInt64)!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x667a16294a089ef8/contract/SomePlaceCollectible
	access(all)
	fun getSomePlaceCollectibleNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "SomePlaceCollectible",
				address: 0x667a16294a089ef8,
				storage_path: "SomePlaceCollectible.CollectionStoragePath",
				public_path: "SomePlaceCollectible.CollectionPublicPath",
				public_collection_name: "SomePlaceCollectible.CollectibleCollectionPublic",
				external_domain: "https://some.place"
			)
		let col =
			owner.capabilities.get<&{SomePlaceCollectible.CollectibleCollectionPublic}>(
				SomePlaceCollectible.CollectionPublicPath
			).borrow<&{SomePlaceCollectible.CollectibleCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let optNft = (col!).borrowCollectible(id: id)
		if optNft == nil{ 
			return nil
		}
		let nft = optNft!
		let setID = nft.setID
		let setMetadata = SomePlaceCollectible.getMetadataForSetID(setID: setID)!
		let editionMetadata = SomePlaceCollectible.getMetadataForNFTByUUID(uuid: nft.id)!
		return NFTData(
			_contract: _contract,
			id: nft.id,
			uuid: nft.uuid,
			title: editionMetadata.getMetadata()["title"]
			?? setMetadata.getMetadata()["title"] ?? "",
			description: editionMetadata.getMetadata()["description"]
			?? setMetadata.getMetadata()["description"] ?? "",
			external_domain_view_url: "https://some.place",
			token_uri: nil,
			media: [
				NFTMedia(
					uri: editionMetadata.getMetadata()["mediaURL"]
					?? setMetadata.getMetadata()["mediaURL"] ?? "",
					mimetype: "image"
				)
			],
			metadata:{ 
				"editionNumber": nft.editionNumber.toString(),
				"editionCount": setMetadata.getMaxNumberOfEditions().toString(),
				"royaltyAddress": "0x8e2e0ebf3c03aa88",
				"royaltyPercentage": "10.0"
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x24de869c5e40b2eb/contract/ARTIFACT
	access(all)
	fun getARTIFACT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "ARTIFACT",
				address: 0x24de869c5e40b2eb,
				storage_path: "ARTIFACT.collectionStoragePath",
				public_path: "ARTIFACT.collectionPublicPath",
				public_collection_name: "ARTIFACT.CollectionPublic",
				external_domain: "https://artifact.scmp.com/"
			)
		let col =
			owner.capabilities.get<&{ARTIFACT.CollectionPublic}>(ARTIFACT.collectionPublicPath)
				.borrow<&{ARTIFACT.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrow(id: id)
		if nft == nil{ 
			return nil
		}
		var metadata = (nft!).data.metadata
		let title = metadata["artifactName"]!
		let description = metadata["artifactShortDescription"]!
		let series = metadata["artifactLookupId"]!
		metadata["editionNumber"] = metadata["artifactEditionNumber"]!
		metadata["editionCount"] = metadata["artifactNumberOfEditions"]!
		metadata["royaltyAddress"] = "0xe9e563d7021d6eda"
		metadata["royaltyPercentage"] = "10.0"
		metadata["rarity"] = metadata["artifactRarityLevel"]!
		let rawMetadata:{ String: String?} ={} 
		for key in metadata.keys{ 
			rawMetadata.insert(key: key, metadata[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: title,
			description: description,
			external_domain_view_url: "https://artifact.scmp.com/".concat(series),
			token_uri: nil,
			media: [NFTMedia(uri: metadata["artifactFileUri"], mimetype: "video/mp4")],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x24de869c5e40b2eb/contract/ARTIFACTPack
	access(all)
	fun getARTIFACTPack(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "ARTIFACTPack",
				address: 0x24de869c5e40b2eb,
				storage_path: "ARTIFACTPack.collectionStoragePath",
				public_path: "ARTIFACTPack.collectionPublicPath",
				public_collection_name: "ARTIFACTPack.CollectionPublic",
				external_domain: "https://artifact.scmp.com/"
			)
		let col =
			owner.capabilities.get<&{ARTIFACTPack.CollectionPublic}>(
				ARTIFACTPack.collectionPublicPath
			).borrow<&{ARTIFACTPack.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrow(id: id)
		if nft == nil{ 
			return nil
		}
		var description = ""
		var mediaUri = ""
		let isOpen = (nft!).isOpen
		var metadata = (nft!).metadata
		var series = metadata["lookupId"]!
		var title = metadata["name"]!
		if isOpen{ 
			description = metadata["descriptionOpened"]!
			mediaUri = metadata["fileUriOpened"]!
		} else{ 
			description = metadata["descriptionUnopened"]!
			mediaUri = metadata["fileUriUnopened"]!
		}
		metadata["editionNumber"] = (nft!).edition.toString()
		metadata["editionCount"] = metadata["numberOfEditions"]!
		metadata["royaltyAddress"] = "0xe9e563d7021d6eda"
		metadata["royaltyPercentage"] = "10.0"
		metadata["rarity"] = metadata["rarityLevel"]!
		let rawMetadata:{ String: String?} ={} 
		for key in metadata.keys{ 
			rawMetadata.insert(key: key, metadata[key])
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: title,
			description: description,
			external_domain_view_url: "https://artifact.scmp.com/".concat(series),
			token_uri: nil,
			media: [NFTMedia(uri: mediaUri, mimetype: "image/png")],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x5892036f9111fbb8/contract/NftReality
	access(all)
	fun getNftRealityNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "NftReality",
				address: 0x5892036f9111fbb8,
				storage_path: "NftReality.CollectionStoragePath",
				public_path: "NftReality.CollectionPublicPath",
				public_collection_name: "NftReality.NftRealityCollectionPublic",
				external_domain: "nftreality.pl"
			)
		let col =
			owner.capabilities.get<&{NftReality.NftRealityCollectionPublic}>(
				NftReality.CollectionPublicPath
			).borrow<&{NftReality.NftRealityCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowNftReality(id: id)
		if nft == nil{ 
			return nil
		}
		let displayView = (nft!).resolveView(Type<MetadataViews.Display>())!
		let display = displayView as! MetadataViews.Display
		let ipfsFile = display.thumbnail as! MetadataViews.IPFSFile
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: display.name,
			description: display.description,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://ipfs.io/ipfs/".concat(ipfsFile.cid).concat("/").concat(
						ipfsFile.path!
					),
					mimetype: "image"
				)
			],
			metadata:{ 
				"editionNumber": (nft!).unit.toString(),
				"editionCount": (nft!).totalUnits.toString(),
				"company": (nft!).metadata.company,
				"role": (nft!).metadata.role,
				"description": (nft!).metadata.description,
				"artwork": (nft!).metadata.artwork,
				"logotype": (nft!).metadata.logotype,
				"creator": (nft!).metadata.creator,
				"creationDate": (nft!).metadata.creationDate
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xf20df769e658c257/contract/MatrixWorldAssetsNFT
	access(all)
	fun getNftMatrixWorldAssetsNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "MatrixWorldAssetsNFT",
				address: 0xf20df769e658c257,
				storage_path: "MatrixWorldAssetsNFT.collectionStoragePath",
				public_path: "MatrixWorldAssetsNFT.collectionPublicPath",
				public_collection_name: "NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MatrixWorldAssetsNFT.Metadata", // interfaces required for initialization
				
				external_domain: "https://matrixworld.org"
			)
		let col =
			owner.capabilities.get<
				&{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}
			>(MatrixWorldAssetsNFT.collectionPublicPath).borrow<
				&{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}
			>()
			?? panic("NFT Collection not found")
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowNFT(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = col.getMetadata(id: id)
		let rawMetadata:{ String: String?} ={} 
		for key in metadata.keys{ 
			rawMetadata.insert(key: key, metadata[key])
		}
		return NFTData(
			_contract: _contract,
			id: id,
			uuid: nft.uuid,
			title: metadata["name"],
			description: metadata["description"],
			external_domain_view_url: "https://matrixworld.org/profile",
			token_uri: nil,
			media: [NFTMedia(uri: metadata["image"], mimetype: "image")],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x8d4fa88ffa2d9117/contract/RacingTime
	access(all)
	fun getRacingTimeNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "RacingTimeNFT",
				address: 0x8d4fa88ffa2d9117,
				storage_path: "RacingTime.CollectionStoragePath",
				public_path: "RacingTime.CollectionPublicPath",
				public_collection_name: "RacingTime.CollectionPublic",
				external_domain: "https://www.racingtime.io/"
			)
		let col =
			owner.capabilities.get<&{RacingTime.RacingTimeCollectionPublic}>(
				RacingTime.CollectionPublicPath
			).borrow<&{RacingTime.RacingTimeCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowRacingTime(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: UInt64(((nft!).data!).rewardID),
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [NFTMedia(uri: ((nft!).data!).ipfs, mimetype: "image")],
			metadata:{ 
				"rewardID": ((nft!).data!).rewardID.toString(),
				"typeID": ((nft!).data!).typeID.toString(),
				"serialNumber": ((nft!).data!).serialNumber.toString(),
				"ipfs": ((nft!).data!).ipfs
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x9d21537544d9123d/contract/Momentables
	access(all)
	fun getMomentables(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Momentables",
				address: 0x9d21537544d9123d,
				storage_path: "Momentables.CollectionStoragePath",
				public_path: "Momentables.CollectionPublicPath",
				public_collection_name: "Momentables.MomentablesCollectionPublic",
				external_domain: "https://nextdecentrum.com"
			)
		let col =
			owner.capabilities.get<&{Momentables.MomentablesCollectionPublic}>(
				Momentables.CollectionPublicPath
			).borrow<&{Momentables.MomentablesCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowMomentables(id: id)
		if nft == nil{ 
			return nil
		}
		
		//let metadata = Gaia.getTemplateMetaData(templateID: nft!.data.templateID)
		let ipfsURL = "https://gateway.pinata.cloud/ipfs/".concat((nft!).imageCID)
		let traits = (nft!).getTraits()
		let rawMetadata:{ String: String?} ={} 
		
		// Core metadata attributes
		rawMetadata.insert(key: "editionNumber", (nft!).id.toString())
		rawMetadata.insert(key: "editionCount", "7006")
		rawMetadata.insert(key: "royaltyAddress", "0x7dc1aa82a2f8d409")
		rawMetadata.insert(key: "royaltyPercentage", "10.1")
		
		// NFT Traits metadata
		for key in traits.keys{ 
			let currentTrait = traits[key]!
			for currentTraitKey in currentTrait.keys{ 
				rawMetadata.insert(key: key.concat("-").concat(currentTraitKey), currentTrait[currentTraitKey])
			}
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name,
			description: (nft!).description,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [NFTMedia(uri: ipfsURL, mimetype: "image")],
			metadata: rawMetadata
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x2068315349bdfce5/contract/GoatedGoats
	access(all)
	fun getGoatedGoats(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "GoatedGoats",
				address: 0x2068315349bdfce5,
				storage_path: "GoatedGoats.CollectionStoragePath",
				public_path: "GoatedGoats.CollectionPublicPath",
				public_collection_name: "GoatedGoats.GoatCollectionPublic",
				external_domain: "https://goatedgoats.com/"
			)
		let col =
			owner.capabilities.get<
				&{ViewResolver.ResolverCollection, GoatedGoats.GoatCollectionPublic}
			>(GoatedGoats.CollectionPublicPath).borrow<
				&{MetadataViews.ResolverCollection, GoatedGoats.GoatCollectionPublic}
			>()
		if col == nil{ 
			return nil
		}
		let optNft = (col!).borrowGoat(id: id)
		if optNft == nil{ 
			return nil
		}
		let nft = optNft!
		let displayView = nft.resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display
		return NFTData(
			_contract: _contract,
			id: nft.id,
			uuid: nft.uuid,
			title: displayView.name,
			description: displayView.description,
			external_domain_view_url: "https://goatedgoats.com",
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://goatedgoats.mypinata.cloud/ipfs/".concat(
						(displayView.thumbnail as! MetadataViews.IPFSFile).cid
					),
					mimetype: "image"
				)
			],
			metadata:{ 
				"editionNumber": nft.goatID.toString(),
				"editionCount": "10000",
				"royaltyAddress": "0xd7081a5c66dc3e7f",
				"royaltyPercentage": "5.0"
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x2068315349bdfce5/contract/GoatedGoatsTrait
	access(all)
	fun getGoatedGoatsTrait(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "GoatedGoatsTrait",
				address: 0x2068315349bdfce5,
				storage_path: "GoatedGoatsTrait.CollectionStoragePath",
				public_path: "GoatedGoatsTrait.CollectionPublicPath",
				public_collection_name: "GoatedGoatsTrait.TraitCollectionPublic",
				external_domain: "https://goatedgoats.com/"
			)
		let col =
			owner.capabilities.get<
				&{ViewResolver.ResolverCollection, GoatedGoatsTrait.TraitCollectionPublic}
			>(GoatedGoatsTrait.CollectionPublicPath).borrow<
				&{MetadataViews.ResolverCollection, GoatedGoatsTrait.TraitCollectionPublic}
			>()
		if col == nil{ 
			return nil
		}
		let optNft = (col!).borrowTrait(id: id)
		if optNft == nil{ 
			return nil
		}
		let nft = optNft!
		let displayView = nft.resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display
		return NFTData(
			_contract: _contract,
			id: nft.id,
			uuid: nft.uuid,
			title: displayView.name,
			description: displayView.description,
			external_domain_view_url: "https://goatedgoats.com",
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://goatedgoats.mypinata.cloud/ipfs/".concat(
						(displayView.thumbnail as! MetadataViews.IPFSFile).cid
					),
					mimetype: "image"
				)
			],
			metadata:{ 
				"editionNumber": nft.id.toString(),
				"editionCount": GoatedGoatsTrait.totalSupply.toString(),
				"royaltyAddress": "0xd7081a5c66dc3e7f",
				"royaltyPercentage": "5.0"
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x2ba17360b76f0143/contract/DropzToken
	access(all)
	fun getDropzToken(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "DropzToken",
				address: 0x2ba17360b76f0143,
				storage_path: "DropzToken.CollectionStoragePath",
				public_path: "DropzToken.CollectionPublicPath",
				public_collection_name: "DropzToken.DropzTokenCollectionPublic",
				external_domain: "https://dropznft.xyz"
			)
		let col =
			owner.capabilities.get<&{DropzToken.DropzTokenCollectionPublic}>(
				DropzToken.CollectionPublicPath
			).borrow<&{DropzToken.DropzTokenCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowDropzToken(id: id)
		if nft == nil{ 
			return nil
		}
		let display = (nft!).resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display
		let thumbnail = display.thumbnail as! MetadataViews.IPFSFile
		let metadata =
			(nft!).resolveView(Type<DropzToken.IPFSTokenMetadata>())!
			as!
			DropzToken.IPFSTokenMetadata
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: display.name,
			description: display.description,
			external_domain_view_url: nil,
			token_uri: metadata.uri(),
			media: [NFTMedia(uri: thumbnail.uri(), mimetype: "image")],
			metadata:{ "ipfs": metadata.uri()}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x718efe5e88fe48ea/contract/Necryptolis
	access(all)
	fun getNecryptolisNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Necryptolis",
				address: 0x718efe5e88fe48ea,
				storage_path: "Necryptolis.CollectionStoragePath",
				public_path: "Necryptolis.CollectionPublicPath",
				public_collection_name: "Necryptolis.NecryptolisCollectionPublic",
				external_domain: "https://www.necryptolis.com"
			)
		let col =
			owner.capabilities.get<&{Necryptolis.NecryptolisCollectionPublic}>(
				Necryptolis.CollectionPublicPath
			).borrow<&{Necryptolis.NecryptolisCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowCemeteryPlot(id: id)
		if nft == nil{ 
			return nil
		}
		let display = (nft!).resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: display.name,
			description: display.description,
			external_domain_view_url: "https://www.necryptolis.com/nft/".concat(
				(nft!).id.toString()
			),
			token_uri: nil,
			media: [NFTMedia(uri: display.thumbnail.uri(), mimetype: "image")],
			metadata:{} 
		)
	}
	
	//https://flow-view-source.com/mainnet/account/0x2d4c3caffbeab845/contract/FLOAT
	access(all)
	fun getFLOAT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "FLOAT",
				address: 0x2d4c3caffbeab845,
				storage_path: "FLOAT.FLOATCollectionStoragePath",
				public_path: "FLOAT.FLOATCollectionPublicPath",
				public_collection_name: "FLOAT.CollectionPublic",
				external_domain: "https://floats.city/"
			)
		let col =
			owner.capabilities.get<&FLOAT.Collection>(FLOAT.FLOATCollectionPublicPath).borrow<
				&FLOAT.Collection
			>()
		if col == nil{ 
			return nil
		}
		let float = (col!).borrowFLOAT(id: id)
		if float == nil{ 
			return nil
		}
		let display = (float!).resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display
		return NFTData(
			_contract: _contract,
			id: (float!).id,
			uuid: (float!).uuid,
			title: display.name,
			description: display.description,
			external_domain_view_url: "https://floats.city/".concat(
				(owner.address as Address).toString()
			).concat("/float/").concat((float!).id.toString()),
			token_uri: nil,
			media: [NFTMedia(uri: (float!).eventImage, mimetype: "image")],
			metadata:{ 
				"eventName": (float!).eventName,
				"eventDescription": (float!).eventDescription,
				"eventHost": ((float!).eventHost as Address).toString(),
				"eventId": (float!).eventId.toString(),
				"eventImage": (float!).eventImage,
				"serial": (float!).serial.toString(),
				"dateReceived": (float!).dateReceived.toString(),
				"royaltyAddress": "0x5643fd47a29770e7",
				"royaltyPercentage": "5.0"
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x329feb3ab062d289/contract/BreakingT_NFT
	access(all)
	fun getBreakingTNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "BreakingT_NFT",
				address: 0x329feb3ab062d289,
				storage_path: "BreakingT_NFT.CollectionStoragePath",
				public_path: "BreakingT_NFT.CollectionPublicPath",
				public_collection_name: "BreakingT_NFT.BreakingT_NFT",
				external_domain: "https://breakingt.com/"
			)
		let col =
			owner.capabilities.get<&{BreakingT_NFT.BreakingT_NFTCollectionPublic}>(
				BreakingT_NFT.CollectionPublicPath
			).borrow<&{BreakingT_NFT.BreakingT_NFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowBreakingT_NFT(id: id)
		if nft == nil{ 
			return nil
		}
		let setMeta = BreakingT_NFT.getSetMetadata(setId: (nft!).setId)!
		let seriesMeta =
			BreakingT_NFT.getSeriesMetadata(
				seriesId: BreakingT_NFT.getSetSeriesId(setId: (nft!).setId)!
			)
		let seriesId = BreakingT_NFT.getSetSeriesId(setId: (nft!).setId)!
		let nftEditions = BreakingT_NFT.getSetMaxEditions(setId: (nft!).setId)!
		let externalTokenViewUrl =
			"https://marketplace.breakingt.com/tokens/".concat((nft!).id.toString())
		var mimeType = "image"
		if ((setMeta!)["image_file_type"]!).toLower() == "mp4"{ 
			mimeType = "video/mp4"
		} else if ((setMeta!)["image_file_type"]!).toLower() == "glb"{ 
			mimeType = "model/gltf-binary"
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (setMeta!)["name"],
			description: (setMeta!)["description"],
			external_domain_view_url: externalTokenViewUrl,
			token_uri: nil,
			media: [
				NFTMedia(uri: (setMeta!)["image"], mimetype: mimeType),
				NFTMedia(uri: (setMeta!)["preview"], mimetype: "image")
			],
			metadata:{ 
				"editionNumber": (nft!).editionNum.toString(),
				"editionCount": (nftEditions!).toString(),
				"set_id": (nft!).setId.toString(),
				"series_id": (seriesId!).toString()
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x41cad19decccdf25/contract/Owners
	access(all)
	fun getOwnersNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Owners",
				address: 0x41cad19decccdf25,
				storage_path: "/storage/OwnersCollection0x41cad19decccdf25",
				public_path: "Owners.CollectionPublicPath",
				public_collection_name: "Owners.OwnersCollectionPublic",
				external_domain: "https://nft-owners.jp"
			)
		let col =
			owner.capabilities.get<&{Owners.OwnersCollectionPublic}>(Owners.CollectionPublicPath)
				.borrow<&{Owners.OwnersCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowOwners(id: id)
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: "https://nft-owners.jp",
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://files.nft-owners.jp/profile_images/".concat(
						(nft!).twitterID.toString()
					).concat(".jpg"),
					mimetype: "image"
				)
			],
			metadata:{ "twitterID": (nft!).twitterID.toString()}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0xd756450f386fb4ac/contract/Metaverse
	access(all)
	fun getOzoneMetaverseNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Metaverse",
				address: 0xd756450f386fb4ac,
				storage_path: "Metaverse.CollectionStoragePath",
				public_path: "Metaverse.CollectionPublicPath",
				public_collection_name: "Metaverse.MetaverseCollectionPublic",
				external_domain: "https://ozonemetaverse.io"
			)
		let col =
			owner.capabilities.get<&{Metaverse.MetaverseCollectionPublic}>(
				Metaverse.CollectionPublicPath
			).borrow<&{Metaverse.MetaverseCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowMetaverse(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: nil,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata:{} 
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x1e075b24abe6eca6/contract/NFTContract
	access(all)
	fun getNFTContract(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "NFTContract",
				address: 0x1e075b24abe6eca6,
				storage_path: "NFTContract.CollectionStoragePath",
				public_path: "NFTContract.CollectionPublicPath",
				public_collection_name: "NFTContract.CollectionPublic",
				external_domain: "https://nowwhere.io/"
			)
		let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				NFTContract.CollectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nftData = (col!).borrowNFT(id: id)
		var nftMetaData:{ String: String} ={} 
		let nft = NFTContract.getNFTDataById(nftId: id)!
		if nft == nil{ 
			return nil
		}
		let templateData = NFTContract.getTemplateById(templateId: (nft!).templateID)
		let immutableData = templateData.getImmutableData()
		var templateDescription:{ String: AnyStruct} ={} 
		templateDescription = templateData.getImmutableData() as!{ String: AnyStruct}
		var extras:{ String: AnyStruct} ={} 
		extras = templateDescription["extras"]! as!{ String: AnyStruct}
		var description: String? = nil
		if extras["Description"] != nil{ 
			description = extras["Description"]! as? String
		}
		return NFTData(
			_contract: _contract,
			id: nftData.id,
			uuid: nftData.uuid,
			title: immutableData["title"]! as? String,
			description: description,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [NFTMedia(uri: immutableData["contectValue"]! as? String, mimetype: "image")],
			metadata:{ 
				"editionNumber": (nft!).mintNumber.toString(),
				"editionCount": templateData.issuedSupply.toString(),
				"artist": templateDescription["artist"]! as? String,
				"mintType": templateDescription["mintType"]! as? String,
				"contectType": templateDescription["contectType"]! as? String,
				"artistEmail": templateDescription["artistEmail"]! as? String,
				"contectValue": templateDescription["contectValue"]! as? String,
				"nftType": templateDescription["nftType"]! as? String,
				"rarity": templateDescription["rarity"]! as? String,
				"mintType": templateDescription["mintType"]! as? String
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x5dfbd0d5aba6acf7/contract/SwaychainNFT
	access(all)
	fun getSwaychainNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "Swaychain",
				address: 0x5dfbd0d5aba6acf7,
				storage_path: "SwaychainNFT.CollectionStoragePath",
				public_path: "SwaychainNFT.CollectionPublicPath",
				public_collection_name: "ShawychainNFT.SwaychainNFTCollectionPublic",
				external_domain: "https://swaychain.com/"
			)
		let col =
			owner.capabilities.get<&{SwaychainNFT.SwaychainNFTCollectionPublic}>(
				SwaychainNFT.CollectionPublicPath
			).borrow<&{SwaychainNFT.SwaychainNFTCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowSwaychainNFT(id: id)
		if nft == nil{ 
			return nil
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name,
			description: (nft!).description,
			external_domain_view_url: (nft!).thumbnail,
			token_uri: nil,
			media: [NFTMedia(uri: (nft!).thumbnail, mimetype: "image")],
			metadata:{ 
				"name": (nft!).name,
				// "message": nft!.title,
				"description": (nft!).description,
				"thumbnail": (nft!).thumbnail
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x7752ea736384322f/contract/TheFabricantS2ItemNFT
	access(all)
	fun getTheFabricantS2ItemNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "TheFabricantS2ItemNFT",
				address: 0x7752ea736384322f,
				storage_path: "TheFabricantS2ItemNFT.CollectionStoragePath",
				public_path: "TheFabricantS2ItemNFT.CollectionPublicPath",
				public_collection_name: "TheFabricantS2ItemNFT.ItemCollectionPublic",
				external_domain: ""
			)
		let col =
			owner.capabilities.get<&{TheFabricantS2ItemNFT.ItemCollectionPublic}>(
				TheFabricantS2ItemNFT.CollectionPublicPath
			).borrow<&{TheFabricantS2ItemNFT.ItemCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowItem(id: id)!
		if nft == nil{ 
			return nil
		}
		let itemDataID = nft.item.itemDataID
		let itemData = TheFabricantS2ItemNFT.getItemData(id: itemDataID)
		let itemMetadata = itemData.getMetadata()
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: (nft!).name,
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [
				NFTMedia(uri: (itemMetadata["itemVideo"]!).metadataValue, mimetype: "video"),
				NFTMedia(uri: (itemMetadata["itemImage"]!).metadataValue, mimetype: "image")
			],
			metadata:{ 
				"name": (nft!).name,
				"primaryColor": (itemMetadata["primaryColor"]!).metadataValue,
				"secondaryColor": (itemMetadata["secondaryColor"]!).metadataValue,
				"coCreator": itemData.coCreator.toString(),
				"season": (itemMetadata["season"]!).metadataValue
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x7c11edb826692404/contract/VnMiss
	access(all)
	fun getVnMiss(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "VnMiss",
				address: 0x7c11edb826692404,
				storage_path: "VnMiss.CollectionStoragePath",
				public_path: "VnMiss.CollectionPublicPath",
				public_collection_name: "VnMiss.VnMissCollectionPublic",
				external_domain: "https://hoahauhoanvuvietnam.avatarart.io"
			)
		let col =
			owner.capabilities.get<&{VnMiss.VnMissCollectionPublic}>(VnMiss.CollectionPublicPath)
				.borrow<&{VnMiss.VnMissCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowVnMiss(id: id)
		if nft == nil{ 
			return nil
		}
		let displayView = (nft!).resolveView(Type<MetadataViews.Display>())!
		let display = displayView as! MetadataViews.Display
		let levelAsString = fun (level: UInt8): String{ 
				switch level{ 
					case VnMiss.Level.Bronze.rawValue:
						return "Bronze"
					case VnMiss.Level.Silver.rawValue:
						return "Silver"
					case VnMiss.Level.Diamond.rawValue:
						return "Diamond"
				}
				return "Unknown"
			}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: display.name,
			description: display.description,
			external_domain_view_url: "https://avatarart.io/nfts/A.7c11edb826692404.VnMiss.NFT."
				.concat((nft!).id.toString()),
			token_uri: nil,
			media: [NFTMedia(uri: display.thumbnail.uri(), mimetype: "image")],
			metadata:{ 
				"name": display.name,
				"level": levelAsString((nft!).level),
				"editionNumber": (nft!).id.toString(),
				"editionCount": "14200",
				"royaltyAddress": "0xe7da9bede73c8cc2",
				"royaltyPercentage": "5.0"
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x39eeb4ee6f30fc3f/contract/AADigital
	access(all)
	fun getAvatarArt(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "AADigital",
				address: 0x39eeb4ee6f30fc3f,
				storage_path: "AADigital.CollectionStoragePath",
				public_path: "AADigital.CollectionPublicPath",
				public_collection_name: "AADigital.AADigitalCollectionPublic",
				external_domain: "https://avatarart.io"
			)
		let col =
			owner.capabilities.get<&{AADigital.AADigitalCollectionPublic}>(
				AADigital.CollectionPublicPath
			).borrow<&{AADigital.AADigitalCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowAADigital(id: id)
		if nft == nil{ 
			return nil
		}
		let displayView = (nft!).resolveView(Type<MetadataViews.Display>())!
		let display = displayView as! MetadataViews.Display
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: display.name,
			description: display.description,
			external_domain_view_url: "https://avatarart.io/nfts/A.39eeb4ee6f30fc3f.AADigital.NFT."
				.concat((nft!).id.toString()),
			token_uri: nil,
			media: [
				NFTMedia(
					uri: "https://api.avatarart.io/upload".concat(display.thumbnail.uri()),
					mimetype: "image"
				)
			],
			metadata:{ 
				"editionNumber": "1",
				"editionCount": AADigital.totalSupply.toString(),
				"royaltyAddress": "0xe7da9bede73c8cc2",
				"royaltyPercentage": "5.0"
			}
		)
	}
	
	// https://flow-view-source.com/mainnet/account/0x66ad29c7d7465437/contract/DooverseItems
	access(all)
	fun getDooverseNFT(owner: &Account, id: UInt64): NFTData?{ 
		let _contract =
			NFTContractData(
				name: "DooverseItems",
				address: 0x66ad29c7d7465437,
				storage_path: "DooverseItems.CollectionStoragePath",
				public_path: "DooverseItems.CollectionPublicPath",
				public_collection_name: "DooverseItems.DooverseItemsCollectionPublic",
				external_domain: "https://dooverse.io/"
			)
		let col =
			owner.capabilities.get<&{DooverseItems.DooverseItemsCollectionPublic}>(
				DooverseItems.CollectionPublicPath
			).borrow<&{DooverseItems.DooverseItemsCollectionPublic}>()
		if col == nil{ 
			return nil
		}
		let nft = (col!).borrowDooverseItem(id: id)
		if nft == nil{ 
			return nil
		}
		let metadata = (nft!).getMetadata()
		let rawMetadata:{ String: String?} ={} 
		for key in metadata.keys{ 
			rawMetadata[key] = metadata[key]
		}
		if !metadata.containsKey("editionNumber"){ 
			rawMetadata.insert(key: "editionNumber", (nft!).id.toString())
		}
		if !metadata.containsKey("editionCount"){ 
			rawMetadata.insert(key: "editionCount", DooverseItems.totalSupply.toString())
		}
		if !metadata.containsKey("royaltyAddress"){ 
			rawMetadata.insert(key: "royaltyAddress", "0x6b43b691ea37ee22")
		}
		if !metadata.containsKey("royaltyPercentage"){ 
			rawMetadata.insert(key: "royaltyPercentage", "5")
		}
		return NFTData(
			_contract: _contract,
			id: (nft!).id,
			uuid: (nft!).uuid,
			title: "Dooverse Items NFT",
			description: nil,
			external_domain_view_url: nil,
			token_uri: nil,
			media: [],
			metadata: rawMetadata
		)
	}
	
	// Same method signature as getNFTIDs.cdc for backwards-compatability.
	access(all)
	fun getNFTIDs(ownerAddress: Address):{ String: [UInt64]}{ 
		let owner = getAccount(ownerAddress)
		let ids:{ String: [UInt64]} ={} 
		if let col =
			owner.capabilities.get<&{CNN_NFT.CNN_NFTCollectionPublic}>(CNN_NFT.CollectionPublicPath)
				.borrow<&{CNN_NFT.CNN_NFTCollectionPublic}>(){ 
			ids["CNN"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}>(
				/public/ChainmonstersRewardCollection
			).borrow<&{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}>(){ 
			ids["ChainmonstersRewards"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Gaia.CollectionPublic}>(Gaia.CollectionPublicPath).borrow<
				&{Gaia.CollectionPublic}
			>(){ 
			ids["Gaia"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Beam.BeamCollectionPublic}>(Beam.CollectionPublicPath).borrow<
				&{Beam.BeamCollectionPublic}
			>(){ 
			ids["Beam"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{BlockleteGames_NFT.BlockleteGames_NFTCollectionPublic}>(
				BlockleteGames_NFT.CollectionPublicPath
			).borrow<&{BlockleteGames_NFT.BlockleteGames_NFTCollectionPublic}>(){ 
			ids["BlockleteGames_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Crave.CraveCollectionPublic}>(Crave.CollectionPublicPath)
				.borrow<&{Crave.CraveCollectionPublic}>(){ 
			ids["Crave"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{CricketMoments.CricketMomentsCollectionPublic}>(
				CricketMoments.CollectionPublicPath
			).borrow<&{CricketMoments.CricketMomentsCollectionPublic}>(){ 
			ids["CricketMoments"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Everbloom.PrintCollectionPublic}>(
				Everbloom.CollectionPublicPath
			).borrow<&{Everbloom.PrintCollectionPublic}>(){ 
			ids["Everbloom"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Shard.ShardCollectionPublic}>(/public/EternalShardCollection)
				.borrow<&{Shard.ShardCollectionPublic}>(){ 
			ids["EternalShard"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{FantastecNFT.FantastecNFTCollectionPublic}>(
				FantastecNFT.CollectionPublicPath
			).borrow<&{FantastecNFT.FantastecNFTCollectionPublic}>(){ 
			ids["FantastecNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Vouchers.CollectionPublic}>(Vouchers.CollectionPublicPath)
				.borrow<&{Vouchers.CollectionPublic}>(){ 
			ids["Vouchers"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{KOTD.NiftoryCollectibleCollectionPublic}>(
				KOTD.CollectionPublicPath
			).borrow<&{KOTD.NiftoryCollectibleCollectionPublic}>(){ 
			ids["KOTD"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{KlktnNFT.KlktnNFTCollectionPublic}>(
				KlktnNFT.CollectionPublicPath
			).borrow<&{KlktnNFT.KlktnNFTCollectionPublic}>(){ 
			ids["KlktnNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{KlktnNFT2.KlktnNFTCollectionPublic}>(
				KlktnNFT2.CollectionPublicPath
			).borrow<&{KlktnNFT2.KlktnNFTCollectionPublic}>(){ 
			ids["KlktnNFT2"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{MusicBlock.MusicBlockCollectionPublic}>(
				MusicBlock.CollectionPublicPath
			).borrow<&{MusicBlock.MusicBlockCollectionPublic}>(){ 
			ids["MusicBlock"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Mynft.MynftCollectionPublic}>(Mynft.CollectionPublicPath)
				.borrow<&{Mynft.MynftCollectionPublic}>(){ 
			ids["Mynft"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NyatheesOVO.NFTCollectionPublic}>(
				NyatheesOVO.CollectionPublicPath
			).borrow<&{NyatheesOVO.NFTCollectionPublic}>(){ 
			ids["NyatheesOVO"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{RaceDay_NFT.RaceDay_NFTCollectionPublic}>(
				RaceDay_NFT.CollectionPublicPath
			).borrow<&{RaceDay_NFT.RaceDay_NFTCollectionPublic}>(){ 
			ids["RaceDay_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{RareRooms_NFT.RareRooms_NFTCollectionPublic}>(
				RareRooms_NFT.CollectionPublicPath
			).borrow<&{RareRooms_NFT.RareRooms_NFTCollectionPublic}>(){ 
			ids["RareRooms_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				RCRDSHPNFT.collectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>(){ 
			ids["RCRDSHPNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{SportsIconCollectible.CollectibleCollectionPublic}>(
				SportsIconCollectible.CollectionPublicPath
			).borrow<&{SportsIconCollectible.CollectibleCollectionPublic}>(){ 
			ids["SportsIconCollectible"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{StarlyCard.StarlyCardCollectionPublic}>(
				StarlyCard.CollectionPublicPath
			).borrow<&{StarlyCard.StarlyCardCollectionPublic}>(){ 
			ids["StarlyCard"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{CaaPass.CollectionPublic}>(CaaPass.CollectionPublicPath)
				.borrow<&{CaaPass.CollectionPublic}>(){ 
			ids["ThingFund"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{TuneGO.TuneGOCollectionPublic}>(TuneGO.CollectionPublicPath)
				.borrow<&{TuneGO.TuneGOCollectionPublic}>(){ 
			ids["TuneGO"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<
				&{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}
			>(MatrixWorldFlowFestNFT.CollectionPublicPath).borrow<
				&{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}
			>(){ 
			ids["MatrixWorldFlowFestNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection)
				.borrow<&{TopShot.MomentCollectionPublic}>(){ 
			ids["TopShot"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Domains.CollectionPublic}>(Domains.CollectionPublicPath)
				.borrow<&{Domains.CollectionPublic}>(){ 
			ids["Domains"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Eternal.MomentCollectionPublic}>(
				/public/EternalMomentCollection
			).borrow<&{Eternal.MomentCollectionPublic}>(){ 
			ids["EternalMoment"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{TFCItems.TFCItemsCollectionPublic}>(
				TFCItems.CollectionPublicPath
			).borrow<&{TFCItems.TFCItemsCollectionPublic}>(){ 
			ids["TFCItems"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{GooberXContract.GooberCollectionPublic}>(
				GooberXContract.CollectionPublicPath
			).borrow<&{GooberXContract.GooberCollectionPublic}>(){ 
			ids["Gooberz"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{MintStoreItem.MintStoreItemCollectionPublic}>(
				MintStoreItem.CollectionPublicPath
			).borrow<&{MintStoreItem.MintStoreItemCollectionPublic}>(){ 
			let mintStoreIDs = col.getIDs()
			for tokenID in mintStoreIDs{ 
				let nft = (col!).borrowMintStoreItem(id: tokenID)
				let merchantName = MintStoreItem.getMerchant(merchantID: (nft!).data.merchantID)!
				let merchKey = "MintStoreItem.".concat(merchantName)
				if ids[merchKey] == nil{ 
					ids[merchKey] = [tokenID]
				} else{ 
					(ids[merchKey]!).append(tokenID)
				}
			}
		}
		if let col =
			owner.capabilities.get<&{BnGNFT.BnGNFTCollectionPublic}>(BnGNFT.CollectionPublicPath)
				.borrow<&{BnGNFT.BnGNFTCollectionPublic}>(){ 
			ids["BiscuitsNGroovy"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{GeniaceNFT.GeniaceNFTCollectionPublic}>(
				GeniaceNFT.CollectionPublicPath
			).borrow<&{GeniaceNFT.GeniaceNFTCollectionPublic}>(){ 
			ids["GeniaceNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Collectible.CollectionPublic}>(
				Collectible.CollectionPublicPath
			).borrow<&{Collectible.CollectionPublic}>(){ 
			ids["Xtingles_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{CryptoZooNFT.CryptoZooNFTCollectionPublic}>(
				CryptoZooNFT.CollectionPublicPath
			).borrow<&{CryptoZooNFT.CryptoZooNFTCollectionPublic}>(){ 
			ids["InceptionAnimals"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<
				&{OneFootballCollectible.OneFootballCollectibleCollectionPublic}
			>(OneFootballCollectible.CollectionPublicPath).borrow<
				&{OneFootballCollectible.OneFootballCollectibleCollectionPublic}
			>(){ 
			ids["OneFootballCollectible"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{TheFabricantMysteryBox_FF1.FabricantCollectionPublic}>(
				TheFabricantMysteryBox_FF1.CollectionPublicPath
			).borrow<&{TheFabricantMysteryBox_FF1.FabricantCollectionPublic}>(){ 
			ids["TheFabricantMysteryBox_FF1"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{DieselNFT.DieselCollectionPublic}>(
				DieselNFT.CollectionPublicPath
			).borrow<&{DieselNFT.DieselCollectionPublic}>(){ 
			ids["DieselNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{MiamiNFT.MiamiCollectionPublic}>(MiamiNFT.CollectionPublicPath)
				.borrow<&{MiamiNFT.MiamiCollectionPublic}>(){ 
			ids["MiamiNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{HaikuNFT.HaikuCollectionPublic}>(
				HaikuNFT.HaikuCollectionPublicPath
			).borrow<&{HaikuNFT.HaikuCollectionPublic}>(){ 
			ids["Bitku"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{FlowChinaBadge.FlowChinaBadgeCollectionPublic}>(
				FlowChinaBadge.CollectionPublicPath
			).borrow<&{FlowChinaBadge.FlowChinaBadgeCollectionPublic}>(){ 
			ids["FlowFans"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{AllDay.MomentNFTCollectionPublic}>(AllDay.CollectionPublicPath)
				.borrow<&{AllDay.MomentNFTCollectionPublic}>(){ 
			ids["AllDay"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				PackNFT.CollectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>(){ 
			ids["PackNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{ItemNFT.ItemCollectionPublic}>(ItemNFT.CollectionPublicPath)
				.borrow<&{ItemNFT.ItemCollectionPublic}>(){ 
			ids["ItemNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{TheFabricantS1ItemNFT.ItemCollectionPublic}>(
				TheFabricantS1ItemNFT.CollectionPublicPath
			).borrow<&{TheFabricantS1ItemNFT.ItemCollectionPublic}>(){ 
			ids["TheFabricantS1ItemNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Andbox_NFT.Andbox_NFTCollectionPublic}>(
				Andbox_NFT.CollectionPublicPath
			).borrow<&{Andbox_NFT.Andbox_NFTCollectionPublic}>(){ 
			ids["Andbox_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{ZeedzINO.ZeedzCollectionPublic}>(ZeedzINO.CollectionPublicPath)
				.borrow<&{ZeedzINO.ZeedzCollectionPublic}>(){ 
			ids["ZeedzINO"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Kicks.KicksCollectionPublic}>(Kicks.CollectionPublicPath)
				.borrow<&{Kicks.KicksCollectionPublic}>(){ 
			ids["Kicks"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}>(
				BarterYardPackNFT.CollectionPublicPath
			).borrow<&{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}>(){ 
			ids["BarterYardPack"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{DayNFT.CollectionPublic}>(DayNFT.CollectionPublicPath).borrow<
				&{DayNFT.CollectionPublic}
			>(){ 
			ids["DayNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Costacos_NFT.Costacos_NFTCollectionPublic}>(
				Costacos_NFT.CollectionPublicPath
			).borrow<&{Costacos_NFT.Costacos_NFTCollectionPublic}>(){ 
			ids["Costacos_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}>(
				Canes_Vault_NFT.CollectionPublicPath
			).borrow<&{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}>(){ 
			ids["Canes_Vault_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{AmericanAirlines_NFT.AmericanAirlines_NFTCollectionPublic}>(
				AmericanAirlines_NFT.CollectionPublicPath
			).borrow<&{AmericanAirlines_NFT.AmericanAirlines_NFTCollectionPublic}>(){ 
			ids["AmericanAirlines_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}>(
				The_Next_Cartel_NFT.CollectionPublicPath
			).borrow<&{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}>(){ 
			ids["The_Next_Cartel_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<
				&{Atheletes_Unlimited_NFT.Atheletes_Unlimited_NFTCollectionPublic}
			>(Atheletes_Unlimited_NFT.CollectionPublicPath).borrow<
				&{Atheletes_Unlimited_NFT.Atheletes_Unlimited_NFTCollectionPublic}
			>(){ 
			ids["Atheletes_Unlimited_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Art_NFT.Art_NFTCollectionPublic}>(Art_NFT.CollectionPublicPath)
				.borrow<&{Art_NFT.Art_NFTCollectionPublic}>(){ 
			ids["Art_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{DGD_NFT.DGD_NFTCollectionPublic}>(DGD_NFT.CollectionPublicPath)
				.borrow<&{DGD_NFT.DGD_NFTCollectionPublic}>(){ 
			ids["DGD_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NowggNFT.NowggNFTCollectionPublic}>(
				NowggNFT.CollectionPublicPath
			).borrow<&{NowggNFT.NowggNFTCollectionPublic}>(){ 
			ids["NowggNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{GogoroCollectible.CollectionPublic}>(
				GogoroCollectible.CollectionPublicPath
			).borrow<&{GogoroCollectible.CollectionPublic}>(){ 
			ids["GogoroCollectible"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{YahooCollectible.CollectionPublic}>(
				YahooCollectible.CollectionPublicPath
			).borrow<&{YahooCollectible.CollectionPublic}>(){ 
			ids["YahooCollectible"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{YahooPartnersCollectible.CollectionPublic}>(
				YahooPartnersCollectible.CollectionPublicPath
			).borrow<&{YahooPartnersCollectible.CollectionPublic}>(){ 
			ids["YahooPartnersCollectible"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				SomePlaceCollectible.CollectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>(){ 
			ids["SomePlaceCollectible"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{ARTIFACTPack.CollectionPublic}>(
				ARTIFACTPack.collectionPublicPath
			).borrow<&{ARTIFACTPack.CollectionPublic}>(){ 
			ids["ARTIFACTPack"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{ARTIFACT.CollectionPublic}>(ARTIFACT.collectionPublicPath)
				.borrow<&{ARTIFACT.CollectionPublic}>(){ 
			ids["ARTIFACT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NftReality.NftRealityCollectionPublic}>(
				NftReality.CollectionPublicPath
			).borrow<&{NftReality.NftRealityCollectionPublic}>(){ 
			ids["NftReality"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				MatrixWorldAssetsNFT.collectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>(){ 
			ids["MatrixWorldAssetsNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{RacingTime.RacingTimeCollectionPublic}>(
				RacingTime.CollectionPublicPath
			).borrow<&{RacingTime.RacingTimeCollectionPublic}>(){ 
			ids["RacingTime"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Momentables.MomentablesCollectionPublic}>(
				Momentables.CollectionPublicPath
			).borrow<&{Momentables.MomentablesCollectionPublic}>(){ 
			ids["Momentables"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				GoatedGoats.CollectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>(){ 
			ids["GoatedGoats"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				GoatedGoatsTrait.CollectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>(){ 
			ids["GoatedGoatsTrait"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{DropzToken.DropzTokenCollectionPublic}>(
				DropzToken.CollectionPublicPath
			).borrow<&{DropzToken.DropzTokenCollectionPublic}>(){ 
			ids["DropzToken"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Necryptolis.NecryptolisCollectionPublic}>(
				Necryptolis.CollectionPublicPath
			).borrow<&{Necryptolis.NecryptolisCollectionPublic}>(){ 
			ids["Necryptolis"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&FLOAT.Collection>(FLOAT.FLOATCollectionPublicPath).borrow<
				&FLOAT.Collection
			>(){ 
			ids["FLOAT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{BreakingT_NFT.BreakingT_NFTCollectionPublic}>(
				BreakingT_NFT.CollectionPublicPath
			).borrow<&{BreakingT_NFT.BreakingT_NFTCollectionPublic}>(){ 
			ids["BreakingT_NFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Owners.OwnersCollectionPublic}>(Owners.CollectionPublicPath)
				.borrow<&{Owners.OwnersCollectionPublic}>(){ 
			ids["Owners"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{Metaverse.MetaverseCollectionPublic}>(
				Metaverse.CollectionPublicPath
			).borrow<&{Metaverse.MetaverseCollectionPublic}>(){ 
			ids["Metaverse"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				NFTContract.CollectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>(){ 
			ids["NFTContract"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{SwaychainNFT.SwaychainNFTCollectionPublic}>(
				SwaychainNFT.CollectionPublicPath
			).borrow<&{SwaychainNFT.SwaychainNFTCollectionPublic}>(){ 
			ids["Swaychain"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{TheFabricantS2ItemNFT.ItemCollectionPublic}>(
				TheFabricantS2ItemNFT.CollectionPublicPath
			).borrow<&{TheFabricantS2ItemNFT.ItemCollectionPublic}>(){ 
			ids["TheFabricantS2ItemNFT"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{VnMiss.VnMissCollectionPublic}>(VnMiss.CollectionPublicPath)
				.borrow<&{VnMiss.VnMissCollectionPublic}>(){ 
			ids["VnMiss"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{AADigital.AADigitalCollectionPublic}>(
				AADigital.CollectionPublicPath
			).borrow<&{AADigital.AADigitalCollectionPublic}>(){ 
			ids["AvatarArt"] = col.getIDs()
		}
		if let col =
			owner.capabilities.get<&{NonFungibleToken.CollectionPublic}>(
				DooverseItems.CollectionPublicPath
			).borrow<&{NonFungibleToken.CollectionPublic}>(){ 
			ids["Dooverse"] = col.getIDs()
		}
		return ids
	}
}
